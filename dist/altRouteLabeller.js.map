{"version":3,"file":"altRouteLabeller.js","sources":["../node_modules/@turf/helpers/index.js","../node_modules/@turf/meta/index.js","../node_modules/@turf/invariant/index.js","../node_modules/@turf/bearing/index.js","../node_modules/@turf/destination/index.js","../node_modules/@turf/distance/index.js","../node_modules/@turf/along/index.js","../node_modules/@turf/length/index.js","../node_modules/ramda/es/internal/_isPlaceholder.js","../node_modules/ramda/es/internal/_curry1.js","../node_modules/ramda/es/internal/_curry2.js","../node_modules/ramda/es/add.js","../node_modules/ramda/es/internal/_arity.js","../node_modules/ramda/es/internal/_curryN.js","../node_modules/ramda/es/curryN.js","../node_modules/ramda/es/internal/_curry3.js","../node_modules/ramda/es/internal/_isArray.js","../node_modules/ramda/es/internal/_isTransformer.js","../node_modules/ramda/es/internal/_dispatchable.js","../node_modules/ramda/es/internal/_xfBase.js","../node_modules/ramda/es/internal/_isString.js","../node_modules/ramda/es/internal/_isArrayLike.js","../node_modules/ramda/es/internal/_xwrap.js","../node_modules/ramda/es/bind.js","../node_modules/ramda/es/internal/_reduce.js","../node_modules/ramda/es/internal/_xmap.js","../node_modules/ramda/es/internal/_has.js","../node_modules/ramda/es/internal/_isArguments.js","../node_modules/ramda/es/keys.js","../node_modules/ramda/es/map.js","../node_modules/ramda/es/internal/_map.js","../node_modules/ramda/es/internal/_isInteger.js","../node_modules/ramda/es/nth.js","../node_modules/ramda/es/paths.js","../node_modules/ramda/es/path.js","../node_modules/ramda/es/prop.js","../node_modules/ramda/es/reduce.js","../node_modules/ramda/es/curry.js","../node_modules/ramda/es/internal/_pipe.js","../node_modules/ramda/es/internal/_checkForMethod.js","../node_modules/ramda/es/slice.js","../node_modules/ramda/es/tail.js","../node_modules/ramda/es/pipe.js","../node_modules/ramda/es/defaultTo.js","../node_modules/ramda/es/remove.js","../node_modules/ramda/es/internal/_xdropRepeatsWith.js","../node_modules/ramda/es/last.js","../node_modules/ramda/es/dropRepeatsWith.js","../node_modules/ramda/es/sum.js","../node_modules/ramda/es/mean.js","../index.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @module helpers\n */\n/**\n * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.\n *\n * @memberof helpers\n * @type {number}\n */\nexports.earthRadius = 6371008.8;\n/**\n * Unit of measurement factors using a spherical (non-ellipsoid) earth radius.\n *\n * @memberof helpers\n * @type {Object}\n */\nexports.factors = {\n    centimeters: exports.earthRadius * 100,\n    centimetres: exports.earthRadius * 100,\n    degrees: exports.earthRadius / 111325,\n    feet: exports.earthRadius * 3.28084,\n    inches: exports.earthRadius * 39.370,\n    kilometers: exports.earthRadius / 1000,\n    kilometres: exports.earthRadius / 1000,\n    meters: exports.earthRadius,\n    metres: exports.earthRadius,\n    miles: exports.earthRadius / 1609.344,\n    millimeters: exports.earthRadius * 1000,\n    millimetres: exports.earthRadius * 1000,\n    nauticalmiles: exports.earthRadius / 1852,\n    radians: 1,\n    yards: exports.earthRadius / 1.0936,\n};\n/**\n * Units of measurement factors based on 1 meter.\n *\n * @memberof helpers\n * @type {Object}\n */\nexports.unitsFactors = {\n    centimeters: 100,\n    centimetres: 100,\n    degrees: 1 / 111325,\n    feet: 3.28084,\n    inches: 39.370,\n    kilometers: 1 / 1000,\n    kilometres: 1 / 1000,\n    meters: 1,\n    metres: 1,\n    miles: 1 / 1609.344,\n    millimeters: 1000,\n    millimetres: 1000,\n    nauticalmiles: 1 / 1852,\n    radians: 1 / exports.earthRadius,\n    yards: 1 / 1.0936,\n};\n/**\n * Area of measurement factors based on 1 square meter.\n *\n * @memberof helpers\n * @type {Object}\n */\nexports.areaFactors = {\n    acres: 0.000247105,\n    centimeters: 10000,\n    centimetres: 10000,\n    feet: 10.763910417,\n    inches: 1550.003100006,\n    kilometers: 0.000001,\n    kilometres: 0.000001,\n    meters: 1,\n    metres: 1,\n    miles: 3.86e-7,\n    millimeters: 1000000,\n    millimetres: 1000000,\n    yards: 1.195990046,\n};\n/**\n * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.\n *\n * @name feature\n * @param {Geometry} geometry input geometry\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature} a GeoJSON Feature\n * @example\n * var geometry = {\n *   \"type\": \"Point\",\n *   \"coordinates\": [110, 50]\n * };\n *\n * var feature = turf.feature(geometry);\n *\n * //=feature\n */\nfunction feature(geom, properties, options) {\n    if (options === void 0) { options = {}; }\n    var feat = { type: \"Feature\" };\n    if (options.id === 0 || options.id) {\n        feat.id = options.id;\n    }\n    if (options.bbox) {\n        feat.bbox = options.bbox;\n    }\n    feat.properties = properties || {};\n    feat.geometry = geom;\n    return feat;\n}\nexports.feature = feature;\n/**\n * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.\n * For GeometryCollection type use `helpers.geometryCollection`\n *\n * @name geometry\n * @param {string} type Geometry Type\n * @param {Array<any>} coordinates Coordinates\n * @param {Object} [options={}] Optional Parameters\n * @returns {Geometry} a GeoJSON Geometry\n * @example\n * var type = \"Point\";\n * var coordinates = [110, 50];\n * var geometry = turf.geometry(type, coordinates);\n * // => geometry\n */\nfunction geometry(type, coordinates, options) {\n    if (options === void 0) { options = {}; }\n    switch (type) {\n        case \"Point\": return point(coordinates).geometry;\n        case \"LineString\": return lineString(coordinates).geometry;\n        case \"Polygon\": return polygon(coordinates).geometry;\n        case \"MultiPoint\": return multiPoint(coordinates).geometry;\n        case \"MultiLineString\": return multiLineString(coordinates).geometry;\n        case \"MultiPolygon\": return multiPolygon(coordinates).geometry;\n        default: throw new Error(type + \" is invalid\");\n    }\n}\nexports.geometry = geometry;\n/**\n * Creates a {@link Point} {@link Feature} from a Position.\n *\n * @name point\n * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Point>} a Point feature\n * @example\n * var point = turf.point([-75.343, 39.984]);\n *\n * //=point\n */\nfunction point(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"Point\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.point = point;\n/**\n * Creates a {@link Point} {@link FeatureCollection} from an Array of Point coordinates.\n *\n * @name points\n * @param {Array<Array<number>>} coordinates an array of Points\n * @param {Object} [properties={}] Translate these properties to each Feature\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Point>} Point Feature\n * @example\n * var points = turf.points([\n *   [-75, 39],\n *   [-80, 45],\n *   [-78, 50]\n * ]);\n *\n * //=points\n */\nfunction points(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return point(coords, properties);\n    }), options);\n}\nexports.points = points;\n/**\n * Creates a {@link Polygon} {@link Feature} from an Array of LinearRings.\n *\n * @name polygon\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Polygon>} Polygon Feature\n * @example\n * var polygon = turf.polygon([[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]], { name: 'poly1' });\n *\n * //=polygon\n */\nfunction polygon(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    for (var _i = 0, coordinates_1 = coordinates; _i < coordinates_1.length; _i++) {\n        var ring = coordinates_1[_i];\n        if (ring.length < 4) {\n            throw new Error(\"Each LinearRing of a Polygon must have 4 or more Positions.\");\n        }\n        for (var j = 0; j < ring[ring.length - 1].length; j++) {\n            // Check if first point of Polygon contains two numbers\n            if (ring[ring.length - 1][j] !== ring[0][j]) {\n                throw new Error(\"First and last Position are not equivalent.\");\n            }\n        }\n    }\n    var geom = {\n        type: \"Polygon\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.polygon = polygon;\n/**\n * Creates a {@link Polygon} {@link FeatureCollection} from an Array of Polygon coordinates.\n *\n * @name polygons\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygon coordinates\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Polygon>} Polygon FeatureCollection\n * @example\n * var polygons = turf.polygons([\n *   [[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]],\n *   [[[-15, 42], [-14, 46], [-12, 41], [-17, 44], [-15, 42]]],\n * ]);\n *\n * //=polygons\n */\nfunction polygons(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return polygon(coords, properties);\n    }), options);\n}\nexports.polygons = polygons;\n/**\n * Creates a {@link LineString} {@link Feature} from an Array of Positions.\n *\n * @name lineString\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<LineString>} LineString Feature\n * @example\n * var linestring1 = turf.lineString([[-24, 63], [-23, 60], [-25, 65], [-20, 69]], {name: 'line 1'});\n * var linestring2 = turf.lineString([[-14, 43], [-13, 40], [-15, 45], [-10, 49]], {name: 'line 2'});\n *\n * //=linestring1\n * //=linestring2\n */\nfunction lineString(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    if (coordinates.length < 2) {\n        throw new Error(\"coordinates must be an array of two or more positions\");\n    }\n    var geom = {\n        type: \"LineString\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.lineString = lineString;\n/**\n * Creates a {@link LineString} {@link FeatureCollection} from an Array of LineString coordinates.\n *\n * @name lineStrings\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<LineString>} LineString FeatureCollection\n * @example\n * var linestrings = turf.lineStrings([\n *   [[-24, 63], [-23, 60], [-25, 65], [-20, 69]],\n *   [[-14, 43], [-13, 40], [-15, 45], [-10, 49]]\n * ]);\n *\n * //=linestrings\n */\nfunction lineStrings(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return lineString(coords, properties);\n    }), options);\n}\nexports.lineStrings = lineStrings;\n/**\n * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.\n *\n * @name featureCollection\n * @param {Feature[]} features input features\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {FeatureCollection} FeatureCollection of Features\n * @example\n * var locationA = turf.point([-75.343, 39.984], {name: 'Location A'});\n * var locationB = turf.point([-75.833, 39.284], {name: 'Location B'});\n * var locationC = turf.point([-75.534, 39.123], {name: 'Location C'});\n *\n * var collection = turf.featureCollection([\n *   locationA,\n *   locationB,\n *   locationC\n * ]);\n *\n * //=collection\n */\nfunction featureCollection(features, options) {\n    if (options === void 0) { options = {}; }\n    var fc = { type: \"FeatureCollection\" };\n    if (options.id) {\n        fc.id = options.id;\n    }\n    if (options.bbox) {\n        fc.bbox = options.bbox;\n    }\n    fc.features = features;\n    return fc;\n}\nexports.featureCollection = featureCollection;\n/**\n * Creates a {@link Feature<MultiLineString>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiLineString\n * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiLineString>} a MultiLineString feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);\n *\n * //=multiLine\n */\nfunction multiLineString(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiLineString\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.multiLineString = multiLineString;\n/**\n * Creates a {@link Feature<MultiPoint>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPoint\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPoint>} a MultiPoint feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPt = turf.multiPoint([[0,0],[10,10]]);\n *\n * //=multiPt\n */\nfunction multiPoint(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiPoint\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.multiPoint = multiPoint;\n/**\n * Creates a {@link Feature<MultiPolygon>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPolygon\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPolygon>} a multipolygon feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);\n *\n * //=multiPoly\n *\n */\nfunction multiPolygon(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiPolygon\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.multiPolygon = multiPolygon;\n/**\n * Creates a {@link Feature<GeometryCollection>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name geometryCollection\n * @param {Array<Geometry>} geometries an array of GeoJSON Geometries\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature\n * @example\n * var pt = turf.geometry(\"Point\", [100, 0]);\n * var line = turf.geometry(\"LineString\", [[101, 0], [102, 1]]);\n * var collection = turf.geometryCollection([pt, line]);\n *\n * // => collection\n */\nfunction geometryCollection(geometries, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"GeometryCollection\",\n        geometries: geometries,\n    };\n    return feature(geom, properties, options);\n}\nexports.geometryCollection = geometryCollection;\n/**\n * Round number to precision\n *\n * @param {number} num Number\n * @param {number} [precision=0] Precision\n * @returns {number} rounded number\n * @example\n * turf.round(120.4321)\n * //=120\n *\n * turf.round(120.4321, 2)\n * //=120.43\n */\nfunction round(num, precision) {\n    if (precision === void 0) { precision = 0; }\n    if (precision && !(precision >= 0)) {\n        throw new Error(\"precision must be a positive number\");\n    }\n    var multiplier = Math.pow(10, precision || 0);\n    return Math.round(num * multiplier) / multiplier;\n}\nexports.round = round;\n/**\n * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name radiansToLength\n * @param {number} radians in radians across the sphere\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, or kilometers inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} distance\n */\nfunction radiansToLength(radians, units) {\n    if (units === void 0) { units = \"kilometers\"; }\n    var factor = exports.factors[units];\n    if (!factor) {\n        throw new Error(units + \" units is invalid\");\n    }\n    return radians * factor;\n}\nexports.radiansToLength = radiansToLength;\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name lengthToRadians\n * @param {number} distance in real units\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, or kilometers inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} radians\n */\nfunction lengthToRadians(distance, units) {\n    if (units === void 0) { units = \"kilometers\"; }\n    var factor = exports.factors[units];\n    if (!factor) {\n        throw new Error(units + \" units is invalid\");\n    }\n    return distance / factor;\n}\nexports.lengthToRadians = lengthToRadians;\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet\n *\n * @name lengthToDegrees\n * @param {number} distance in real units\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, or kilometers inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} degrees\n */\nfunction lengthToDegrees(distance, units) {\n    return radiansToDegrees(lengthToRadians(distance, units));\n}\nexports.lengthToDegrees = lengthToDegrees;\n/**\n * Converts any bearing angle from the north line direction (positive clockwise)\n * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line\n *\n * @name bearingToAzimuth\n * @param {number} bearing angle, between -180 and +180 degrees\n * @returns {number} angle between 0 and 360 degrees\n */\nfunction bearingToAzimuth(bearing) {\n    var angle = bearing % 360;\n    if (angle < 0) {\n        angle += 360;\n    }\n    return angle;\n}\nexports.bearingToAzimuth = bearingToAzimuth;\n/**\n * Converts an angle in radians to degrees\n *\n * @name radiansToDegrees\n * @param {number} radians angle in radians\n * @returns {number} degrees between 0 and 360 degrees\n */\nfunction radiansToDegrees(radians) {\n    var degrees = radians % (2 * Math.PI);\n    return degrees * 180 / Math.PI;\n}\nexports.radiansToDegrees = radiansToDegrees;\n/**\n * Converts an angle in degrees to radians\n *\n * @name degreesToRadians\n * @param {number} degrees angle between 0 and 360 degrees\n * @returns {number} angle in radians\n */\nfunction degreesToRadians(degrees) {\n    var radians = degrees % 360;\n    return radians * Math.PI / 180;\n}\nexports.degreesToRadians = degreesToRadians;\n/**\n * Converts a length to the requested unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @param {number} length to be converted\n * @param {Units} [originalUnit=\"kilometers\"] of the length\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\n * @returns {number} the converted length\n */\nfunction convertLength(length, originalUnit, finalUnit) {\n    if (originalUnit === void 0) { originalUnit = \"kilometers\"; }\n    if (finalUnit === void 0) { finalUnit = \"kilometers\"; }\n    if (!(length >= 0)) {\n        throw new Error(\"length must be a positive number\");\n    }\n    return radiansToLength(lengthToRadians(length, originalUnit), finalUnit);\n}\nexports.convertLength = convertLength;\n/**\n * Converts a area to the requested unit.\n * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeters, acres, miles, yards, feet, inches\n * @param {number} area to be converted\n * @param {Units} [originalUnit=\"meters\"] of the distance\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\n * @returns {number} the converted distance\n */\nfunction convertArea(area, originalUnit, finalUnit) {\n    if (originalUnit === void 0) { originalUnit = \"meters\"; }\n    if (finalUnit === void 0) { finalUnit = \"kilometers\"; }\n    if (!(area >= 0)) {\n        throw new Error(\"area must be a positive number\");\n    }\n    var startFactor = exports.areaFactors[originalUnit];\n    if (!startFactor) {\n        throw new Error(\"invalid original units\");\n    }\n    var finalFactor = exports.areaFactors[finalUnit];\n    if (!finalFactor) {\n        throw new Error(\"invalid final units\");\n    }\n    return (area / startFactor) * finalFactor;\n}\nexports.convertArea = convertArea;\n/**\n * isNumber\n *\n * @param {*} num Number to validate\n * @returns {boolean} true/false\n * @example\n * turf.isNumber(123)\n * //=true\n * turf.isNumber('foo')\n * //=false\n */\nfunction isNumber(num) {\n    return !isNaN(num) && num !== null && !Array.isArray(num) && !/^\\s*$/.test(num);\n}\nexports.isNumber = isNumber;\n/**\n * isObject\n *\n * @param {*} input variable to validate\n * @returns {boolean} true/false\n * @example\n * turf.isObject({elevation: 10})\n * //=true\n * turf.isObject('foo')\n * //=false\n */\nfunction isObject(input) {\n    return (!!input) && (input.constructor === Object);\n}\nexports.isObject = isObject;\n/**\n * Validate BBox\n *\n * @private\n * @param {Array<number>} bbox BBox to validate\n * @returns {void}\n * @throws Error if BBox is not valid\n * @example\n * validateBBox([-180, -40, 110, 50])\n * //=OK\n * validateBBox([-180, -40])\n * //=Error\n * validateBBox('Foo')\n * //=Error\n * validateBBox(5)\n * //=Error\n * validateBBox(null)\n * //=Error\n * validateBBox(undefined)\n * //=Error\n */\nfunction validateBBox(bbox) {\n    if (!bbox) {\n        throw new Error(\"bbox is required\");\n    }\n    if (!Array.isArray(bbox)) {\n        throw new Error(\"bbox must be an Array\");\n    }\n    if (bbox.length !== 4 && bbox.length !== 6) {\n        throw new Error(\"bbox must be an Array of 4 or 6 numbers\");\n    }\n    bbox.forEach(function (num) {\n        if (!isNumber(num)) {\n            throw new Error(\"bbox must only contain numbers\");\n        }\n    });\n}\nexports.validateBBox = validateBBox;\n/**\n * Validate Id\n *\n * @private\n * @param {string|number} id Id to validate\n * @returns {void}\n * @throws Error if Id is not valid\n * @example\n * validateId([-180, -40, 110, 50])\n * //=Error\n * validateId([-180, -40])\n * //=Error\n * validateId('Foo')\n * //=OK\n * validateId(5)\n * //=OK\n * validateId(null)\n * //=Error\n * validateId(undefined)\n * //=Error\n */\nfunction validateId(id) {\n    if (!id) {\n        throw new Error(\"id is required\");\n    }\n    if ([\"string\", \"number\"].indexOf(typeof id) === -1) {\n        throw new Error(\"id must be a number or a string\");\n    }\n}\nexports.validateId = validateId;\n// Deprecated methods\nfunction radians2degrees() {\n    throw new Error(\"method has been renamed to `radiansToDegrees`\");\n}\nexports.radians2degrees = radians2degrees;\nfunction degrees2radians() {\n    throw new Error(\"method has been renamed to `degreesToRadians`\");\n}\nexports.degrees2radians = degrees2radians;\nfunction distanceToDegrees() {\n    throw new Error(\"method has been renamed to `lengthToDegrees`\");\n}\nexports.distanceToDegrees = distanceToDegrees;\nfunction distanceToRadians() {\n    throw new Error(\"method has been renamed to `lengthToRadians`\");\n}\nexports.distanceToRadians = distanceToRadians;\nfunction radiansToDistance() {\n    throw new Error(\"method has been renamed to `radiansToLength`\");\n}\nexports.radiansToDistance = radiansToDistance;\nfunction bearingToAngle() {\n    throw new Error(\"method has been renamed to `bearingToAzimuth`\");\n}\nexports.bearingToAngle = bearingToAngle;\nfunction convertDistance() {\n    throw new Error(\"method has been renamed to `convertLength`\");\n}\nexports.convertDistance = convertDistance;\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar helpers = require('@turf/helpers');\n\n/**\n * Callback for coordEach\n *\n * @callback coordEachCallback\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Iterate over coordinates in any GeoJSON object, similar to Array.forEach()\n *\n * @name coordEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentCoord, coordIndex, featureIndex, multiFeatureIndex)\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordEach(features, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction coordEach(geojson, callback, excludeWrapCoord) {\n    // Handles null Geometry -- Skips this GeoJSON\n    if (geojson === null) return;\n    var j, k, l, geometry, stopG, coords,\n        geometryMaybeCollection,\n        wrapShrink = 0,\n        coordIndex = 0,\n        isGeometryCollection,\n        type = geojson.type,\n        isFeatureCollection = type === 'FeatureCollection',\n        isFeature = type === 'Feature',\n        stop = isFeatureCollection ? geojson.features.length : 1;\n\n    // This logic may look a little weird. The reason why it is that way\n    // is because it's trying to be fast. GeoJSON supports multiple kinds\n    // of objects at its root: FeatureCollection, Features, Geometries.\n    // This function has the responsibility of handling all of them, and that\n    // means that some of the `for` loops you see below actually just don't apply\n    // to certain inputs. For instance, if you give this just a\n    // Point geometry, then both loops are short-circuited and all we do\n    // is gradually rename the input until it's called 'geometry'.\n    //\n    // This also aims to allocate as few resources as possible: just a\n    // few numbers and booleans, rather than any temporary arrays as would\n    // be required with the normalization approach.\n    for (var featureIndex = 0; featureIndex < stop; featureIndex++) {\n        geometryMaybeCollection = (isFeatureCollection ? geojson.features[featureIndex].geometry :\n            (isFeature ? geojson.geometry : geojson));\n        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;\n        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n\n        for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {\n            var multiFeatureIndex = 0;\n            var geometryIndex = 0;\n            geometry = isGeometryCollection ?\n                geometryMaybeCollection.geometries[geomIndex] : geometryMaybeCollection;\n\n            // Handles null Geometry -- Skips this geometry\n            if (geometry === null) continue;\n            coords = geometry.coordinates;\n            var geomType = geometry.type;\n\n            wrapShrink = (excludeWrapCoord && (geomType === 'Polygon' || geomType === 'MultiPolygon')) ? 1 : 0;\n\n            switch (geomType) {\n            case null:\n                break;\n            case 'Point':\n                if (callback(coords, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                coordIndex++;\n                multiFeatureIndex++;\n                break;\n            case 'LineString':\n            case 'MultiPoint':\n                for (j = 0; j < coords.length; j++) {\n                    if (callback(coords[j], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                    coordIndex++;\n                    if (geomType === 'MultiPoint') multiFeatureIndex++;\n                }\n                if (geomType === 'LineString') multiFeatureIndex++;\n                break;\n            case 'Polygon':\n            case 'MultiLineString':\n                for (j = 0; j < coords.length; j++) {\n                    for (k = 0; k < coords[j].length - wrapShrink; k++) {\n                        if (callback(coords[j][k], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                        coordIndex++;\n                    }\n                    if (geomType === 'MultiLineString') multiFeatureIndex++;\n                    if (geomType === 'Polygon') geometryIndex++;\n                }\n                if (geomType === 'Polygon') multiFeatureIndex++;\n                break;\n            case 'MultiPolygon':\n                for (j = 0; j < coords.length; j++) {\n                    geometryIndex = 0;\n                    for (k = 0; k < coords[j].length; k++) {\n                        for (l = 0; l < coords[j][k].length - wrapShrink; l++) {\n                            if (callback(coords[j][k][l], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                            coordIndex++;\n                        }\n                        geometryIndex++;\n                    }\n                    multiFeatureIndex++;\n                }\n                break;\n            case 'GeometryCollection':\n                for (j = 0; j < geometry.geometries.length; j++)\n                    if (coordEach(geometry.geometries[j], callback, excludeWrapCoord) === false) return false;\n                break;\n            default:\n                throw new Error('Unknown Geometry Type');\n            }\n        }\n    }\n}\n\n/**\n * Callback for coordReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback coordReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Reduce coordinates in any GeoJSON object, similar to Array.reduce()\n *\n * @name coordReduce\n * @param {FeatureCollection|Geometry|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentCoord, coordIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordReduce(features, function (previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentCoord;\n * });\n */\nfunction coordReduce(geojson, callback, initialValue, excludeWrapCoord) {\n    var previousValue = initialValue;\n    coordEach(geojson, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n        if (coordIndex === 0 && initialValue === undefined) previousValue = currentCoord;\n        else previousValue = callback(previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex);\n    }, excludeWrapCoord);\n    return previousValue;\n}\n\n/**\n * Callback for propEach\n *\n * @callback propEachCallback\n * @param {Object} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over properties in any GeoJSON object, similar to Array.forEach()\n *\n * @name propEach\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentProperties, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propEach(features, function (currentProperties, featureIndex) {\n *   //=currentProperties\n *   //=featureIndex\n * });\n */\nfunction propEach(geojson, callback) {\n    var i;\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        for (i = 0; i < geojson.features.length; i++) {\n            if (callback(geojson.features[i].properties, i) === false) break;\n        }\n        break;\n    case 'Feature':\n        callback(geojson.properties, 0);\n        break;\n    }\n}\n\n\n/**\n * Callback for propReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback propReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {*} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce properties in any GeoJSON object into a single value,\n * similar to how Array.reduce works. However, in this case we lazily run\n * the reduction, so an array of all properties is unnecessary.\n *\n * @name propReduce\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentProperties, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propReduce(features, function (previousValue, currentProperties, featureIndex) {\n *   //=previousValue\n *   //=currentProperties\n *   //=featureIndex\n *   return currentProperties\n * });\n */\nfunction propReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    propEach(geojson, function (currentProperties, featureIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentProperties;\n        else previousValue = callback(previousValue, currentProperties, featureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for featureEach\n *\n * @callback featureEachCallback\n * @param {Feature<any>} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name featureEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.featureEach(features, function (currentFeature, featureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n * });\n */\nfunction featureEach(geojson, callback) {\n    if (geojson.type === 'Feature') {\n        callback(geojson, 0);\n    } else if (geojson.type === 'FeatureCollection') {\n        for (var i = 0; i < geojson.features.length; i++) {\n            if (callback(geojson.features[i], i) === false) break;\n        }\n    }\n}\n\n/**\n * Callback for featureReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback featureReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name featureReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.featureReduce(features, function (previousValue, currentFeature, featureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   return currentFeature\n * });\n */\nfunction featureReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    featureEach(geojson, function (currentFeature, featureIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentFeature;\n        else previousValue = callback(previousValue, currentFeature, featureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Get all coordinates from any GeoJSON object.\n *\n * @name coordAll\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @returns {Array<Array<number>>} coordinate position array\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * var coords = turf.coordAll(features);\n * //= [[26, 37], [36, 53]]\n */\nfunction coordAll(geojson) {\n    var coords = [];\n    coordEach(geojson, function (coord) {\n        coords.push(coord);\n    });\n    return coords;\n}\n\n/**\n * Callback for geomEach\n *\n * @callback geomEachCallback\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Iterate over each geometry in any GeoJSON object, similar to Array.forEach()\n *\n * @name geomEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomEach(features, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n * });\n */\nfunction geomEach(geojson, callback) {\n    var i, j, g, geometry, stopG,\n        geometryMaybeCollection,\n        isGeometryCollection,\n        featureProperties,\n        featureBBox,\n        featureId,\n        featureIndex = 0,\n        isFeatureCollection = geojson.type === 'FeatureCollection',\n        isFeature = geojson.type === 'Feature',\n        stop = isFeatureCollection ? geojson.features.length : 1;\n\n    // This logic may look a little weird. The reason why it is that way\n    // is because it's trying to be fast. GeoJSON supports multiple kinds\n    // of objects at its root: FeatureCollection, Features, Geometries.\n    // This function has the responsibility of handling all of them, and that\n    // means that some of the `for` loops you see below actually just don't apply\n    // to certain inputs. For instance, if you give this just a\n    // Point geometry, then both loops are short-circuited and all we do\n    // is gradually rename the input until it's called 'geometry'.\n    //\n    // This also aims to allocate as few resources as possible: just a\n    // few numbers and booleans, rather than any temporary arrays as would\n    // be required with the normalization approach.\n    for (i = 0; i < stop; i++) {\n\n        geometryMaybeCollection = (isFeatureCollection ? geojson.features[i].geometry :\n            (isFeature ? geojson.geometry : geojson));\n        featureProperties = (isFeatureCollection ? geojson.features[i].properties :\n            (isFeature ? geojson.properties : {}));\n        featureBBox = (isFeatureCollection ? geojson.features[i].bbox :\n            (isFeature ? geojson.bbox : undefined));\n        featureId = (isFeatureCollection ? geojson.features[i].id :\n            (isFeature ? geojson.id : undefined));\n        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;\n        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n\n        for (g = 0; g < stopG; g++) {\n            geometry = isGeometryCollection ?\n                geometryMaybeCollection.geometries[g] : geometryMaybeCollection;\n\n            // Handle null Geometry\n            if (geometry === null) {\n                if (callback(null, featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                continue;\n            }\n            switch (geometry.type) {\n            case 'Point':\n            case 'LineString':\n            case 'MultiPoint':\n            case 'Polygon':\n            case 'MultiLineString':\n            case 'MultiPolygon': {\n                if (callback(geometry, featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                break;\n            }\n            case 'GeometryCollection': {\n                for (j = 0; j < geometry.geometries.length; j++) {\n                    if (callback(geometry.geometries[j], featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                }\n                break;\n            }\n            default:\n                throw new Error('Unknown Geometry Type');\n            }\n        }\n        // Only increase `featureIndex` per each feature\n        featureIndex++;\n    }\n}\n\n/**\n * Callback for geomReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback geomReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Reduce geometry in any GeoJSON object, similar to Array.reduce().\n *\n * @name geomReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomReduce(features, function (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=previousValue\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n *   return currentGeometry\n * });\n */\nfunction geomReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    geomEach(geojson, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentGeometry;\n        else previousValue = callback(previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for flattenEach\n *\n * @callback flattenEachCallback\n * @param {Feature} currentFeature The current flattened feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Iterate over flattened features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name flattenEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex, multiFeatureIndex)\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenEach(features, function (currentFeature, featureIndex, multiFeatureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n * });\n */\nfunction flattenEach(geojson, callback) {\n    geomEach(geojson, function (geometry, featureIndex, properties, bbox, id) {\n        // Callback for single geometry\n        var type = (geometry === null) ? null : geometry.type;\n        switch (type) {\n        case null:\n        case 'Point':\n        case 'LineString':\n        case 'Polygon':\n            if (callback(helpers.feature(geometry, properties, {bbox: bbox, id: id}), featureIndex, 0) === false) return false;\n            return;\n        }\n\n        var geomType;\n\n        // Callback for multi-geometry\n        switch (type) {\n        case 'MultiPoint':\n            geomType = 'Point';\n            break;\n        case 'MultiLineString':\n            geomType = 'LineString';\n            break;\n        case 'MultiPolygon':\n            geomType = 'Polygon';\n            break;\n        }\n\n        for (var multiFeatureIndex = 0; multiFeatureIndex < geometry.coordinates.length; multiFeatureIndex++) {\n            var coordinate = geometry.coordinates[multiFeatureIndex];\n            var geom = {\n                type: geomType,\n                coordinates: coordinate\n            };\n            if (callback(helpers.feature(geom, properties), featureIndex, multiFeatureIndex) === false) return false;\n        }\n    });\n}\n\n/**\n * Callback for flattenReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback flattenReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Reduce flattened features in any GeoJSON object, similar to Array.reduce().\n *\n * @name flattenReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex, multiFeatureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenReduce(features, function (previousValue, currentFeature, featureIndex, multiFeatureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   return currentFeature\n * });\n */\nfunction flattenReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    flattenEach(geojson, function (currentFeature, featureIndex, multiFeatureIndex) {\n        if (featureIndex === 0 && multiFeatureIndex === 0 && initialValue === undefined) previousValue = currentFeature;\n        else previousValue = callback(previousValue, currentFeature, featureIndex, multiFeatureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for segmentEach\n *\n * @callback segmentEachCallback\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n * @returns {void}\n */\n\n/**\n * Iterate over 2-vertex line segment in any GeoJSON object, similar to Array.forEach()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex)\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentEach(polygon, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //=currentSegment\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   //=segmentIndex\n * });\n *\n * // Calculate the total number of segments\n * var total = 0;\n * turf.segmentEach(polygon, function () {\n *     total++;\n * });\n */\nfunction segmentEach(geojson, callback) {\n    flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {\n        var segmentIndex = 0;\n\n        // Exclude null Geometries\n        if (!feature.geometry) return;\n        // (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n        var type = feature.geometry.type;\n        if (type === 'Point' || type === 'MultiPoint') return;\n\n        // Generate 2-vertex line segments\n        var previousCoords;\n        var previousFeatureIndex = 0;\n        var previousMultiIndex = 0;\n        var prevGeomIndex = 0;\n        if (coordEach(feature, function (currentCoord, coordIndex, featureIndexCoord, multiPartIndexCoord, geometryIndex) {\n            // Simulating a meta.coordReduce() since `reduce` operations cannot be stopped by returning `false`\n            if (previousCoords === undefined || featureIndex > previousFeatureIndex || multiPartIndexCoord > previousMultiIndex || geometryIndex > prevGeomIndex) {\n                previousCoords = currentCoord;\n                previousFeatureIndex = featureIndex;\n                previousMultiIndex = multiPartIndexCoord;\n                prevGeomIndex = geometryIndex;\n                segmentIndex = 0;\n                return;\n            }\n            var currentSegment = helpers.lineString([previousCoords, currentCoord], feature.properties);\n            if (callback(currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) === false) return false;\n            segmentIndex++;\n            previousCoords = currentCoord;\n        }) === false) return false;\n    });\n}\n\n/**\n * Callback for segmentReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback segmentReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n */\n\n/**\n * Reduce 2-vertex line segment in any GeoJSON object, similar to Array.reduce()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (previousValue, currentSegment, currentIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentReduce(polygon, function (previousSegment, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //= previousSegment\n *   //= currentSegment\n *   //= featureIndex\n *   //= multiFeatureIndex\n *   //= geometryIndex\n *   //= segmentInex\n *   return currentSegment\n * });\n *\n * // Calculate the total number of segments\n * var initialValue = 0\n * var total = turf.segmentReduce(polygon, function (previousValue) {\n *     previousValue++;\n *     return previousValue;\n * }, initialValue);\n */\nfunction segmentReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    var started = false;\n    segmentEach(geojson, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n        if (started === false && initialValue === undefined) previousValue = currentSegment;\n        else previousValue = callback(previousValue, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex);\n        started = true;\n    });\n    return previousValue;\n}\n\n/**\n * Callback for lineEach\n *\n * @callback lineEachCallback\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Iterate over line or ring coordinates in LineString, Polygon, MultiLineString, MultiPolygon Features or Geometries,\n * similar to Array.forEach.\n *\n * @name lineEach\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @example\n * var multiLine = turf.multiLineString([\n *   [[26, 37], [35, 45]],\n *   [[36, 53], [38, 50], [41, 55]]\n * ]);\n *\n * turf.lineEach(multiLine, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction lineEach(geojson, callback) {\n    // validation\n    if (!geojson) throw new Error('geojson is required');\n\n    flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {\n        if (feature.geometry === null) return;\n        var type = feature.geometry.type;\n        var coords = feature.geometry.coordinates;\n        switch (type) {\n        case 'LineString':\n            if (callback(feature, featureIndex, multiFeatureIndex, 0, 0) === false) return false;\n            break;\n        case 'Polygon':\n            for (var geometryIndex = 0; geometryIndex < coords.length; geometryIndex++) {\n                if (callback(helpers.lineString(coords[geometryIndex], feature.properties), featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n            }\n            break;\n        }\n    });\n}\n\n/**\n * Callback for lineReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback lineReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed.\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name lineReduce\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var multiPoly = turf.multiPolygon([\n *   turf.polygon([[[12,48],[2,41],[24,38],[12,48]], [[9,44],[13,41],[13,45],[9,44]]]),\n *   turf.polygon([[[5, 5], [0, 0], [2, 2], [4, 4], [5, 5]]])\n * ]);\n *\n * turf.lineReduce(multiPoly, function (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentLine\n * });\n */\nfunction lineReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    lineEach(geojson, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentLine;\n        else previousValue = callback(previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Finds a particular 2-vertex LineString Segment from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n * Point & MultiPoint will always return null.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.segmentIndex=0] Segment Index\n * @param {Object} [options.properties={}] Translate Properties to output LineString\n * @param {BBox} [options.bbox={}] Translate BBox to output LineString\n * @param {number|string} [options.id={}] Translate Id to output LineString\n * @returns {Feature<LineString>} 2-vertex GeoJSON Feature LineString\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findSegment(multiLine);\n * // => Feature<LineString<[[10, 10], [50, 30]]>>\n *\n * // First Segment of 2nd Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: 1});\n * // => Feature<LineString<[[-10, -10], [-50, -30]]>>\n *\n * // Last Segment of Last Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: -1, segmentIndex: -1});\n * // => Feature<LineString<[[-50, -30], [-30, -40]]>>\n */\nfunction findSegment(geojson, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!helpers.isObject(options)) throw new Error('options is invalid');\n    var featureIndex = options.featureIndex || 0;\n    var multiFeatureIndex = options.multiFeatureIndex || 0;\n    var geometryIndex = options.geometryIndex || 0;\n    var segmentIndex = options.segmentIndex || 0;\n\n    // Find FeatureIndex\n    var properties = options.properties;\n    var geometry;\n\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        if (featureIndex < 0) featureIndex = geojson.features.length + featureIndex;\n        properties = properties || geojson.features[featureIndex].properties;\n        geometry = geojson.features[featureIndex].geometry;\n        break;\n    case 'Feature':\n        properties = properties || geojson.properties;\n        geometry = geojson.geometry;\n        break;\n    case 'Point':\n    case 'MultiPoint':\n        return null;\n    case 'LineString':\n    case 'Polygon':\n    case 'MultiLineString':\n    case 'MultiPolygon':\n        geometry = geojson;\n        break;\n    default:\n        throw new Error('geojson is invalid');\n    }\n\n    // Find SegmentIndex\n    if (geometry === null) return null;\n    var coords = geometry.coordinates;\n    switch (geometry.type) {\n    case 'Point':\n    case 'MultiPoint':\n        return null;\n    case 'LineString':\n        if (segmentIndex < 0) segmentIndex = coords.length + segmentIndex - 1;\n        return helpers.lineString([coords[segmentIndex], coords[segmentIndex + 1]], properties, options);\n    case 'Polygon':\n        if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n        if (segmentIndex < 0) segmentIndex = coords[geometryIndex].length + segmentIndex - 1;\n        return helpers.lineString([coords[geometryIndex][segmentIndex], coords[geometryIndex][segmentIndex + 1]], properties, options);\n    case 'MultiLineString':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (segmentIndex < 0) segmentIndex = coords[multiFeatureIndex].length + segmentIndex - 1;\n        return helpers.lineString([coords[multiFeatureIndex][segmentIndex], coords[multiFeatureIndex][segmentIndex + 1]], properties, options);\n    case 'MultiPolygon':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (geometryIndex < 0) geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n        if (segmentIndex < 0) segmentIndex = coords[multiFeatureIndex][geometryIndex].length - segmentIndex - 1;\n        return helpers.lineString([coords[multiFeatureIndex][geometryIndex][segmentIndex], coords[multiFeatureIndex][geometryIndex][segmentIndex + 1]], properties, options);\n    }\n    throw new Error('geojson is invalid');\n}\n\n/**\n * Finds a particular Point from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.coordIndex=0] Coord Index\n * @param {Object} [options.properties={}] Translate Properties to output Point\n * @param {BBox} [options.bbox={}] Translate BBox to output Point\n * @param {number|string} [options.id={}] Translate Id to output Point\n * @returns {Feature<Point>} 2-vertex GeoJSON Feature Point\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findPoint(multiLine);\n * // => Feature<Point<[10, 10]>>\n *\n * // First Segment of the 2nd Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: 1});\n * // => Feature<Point<[-10, -10]>>\n *\n * // Last Segment of last Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: -1, coordIndex: -1});\n * // => Feature<Point<[-30, -40]>>\n */\nfunction findPoint(geojson, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!helpers.isObject(options)) throw new Error('options is invalid');\n    var featureIndex = options.featureIndex || 0;\n    var multiFeatureIndex = options.multiFeatureIndex || 0;\n    var geometryIndex = options.geometryIndex || 0;\n    var coordIndex = options.coordIndex || 0;\n\n    // Find FeatureIndex\n    var properties = options.properties;\n    var geometry;\n\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        if (featureIndex < 0) featureIndex = geojson.features.length + featureIndex;\n        properties = properties || geojson.features[featureIndex].properties;\n        geometry = geojson.features[featureIndex].geometry;\n        break;\n    case 'Feature':\n        properties = properties || geojson.properties;\n        geometry = geojson.geometry;\n        break;\n    case 'Point':\n    case 'MultiPoint':\n        return null;\n    case 'LineString':\n    case 'Polygon':\n    case 'MultiLineString':\n    case 'MultiPolygon':\n        geometry = geojson;\n        break;\n    default:\n        throw new Error('geojson is invalid');\n    }\n\n    // Find Coord Index\n    if (geometry === null) return null;\n    var coords = geometry.coordinates;\n    switch (geometry.type) {\n    case 'Point':\n        return helpers.point(coords, properties, options);\n    case 'MultiPoint':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        return helpers.point(coords[multiFeatureIndex], properties, options);\n    case 'LineString':\n        if (coordIndex < 0) coordIndex = coords.length + coordIndex;\n        return helpers.point(coords[coordIndex], properties, options);\n    case 'Polygon':\n        if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n        if (coordIndex < 0) coordIndex = coords[geometryIndex].length + coordIndex;\n        return helpers.point(coords[geometryIndex][coordIndex], properties, options);\n    case 'MultiLineString':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (coordIndex < 0) coordIndex = coords[multiFeatureIndex].length + coordIndex;\n        return helpers.point(coords[multiFeatureIndex][coordIndex], properties, options);\n    case 'MultiPolygon':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (geometryIndex < 0) geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n        if (coordIndex < 0) coordIndex = coords[multiFeatureIndex][geometryIndex].length - coordIndex;\n        return helpers.point(coords[multiFeatureIndex][geometryIndex][coordIndex], properties, options);\n    }\n    throw new Error('geojson is invalid');\n}\n\nexports.coordEach = coordEach;\nexports.coordReduce = coordReduce;\nexports.propEach = propEach;\nexports.propReduce = propReduce;\nexports.featureEach = featureEach;\nexports.featureReduce = featureReduce;\nexports.coordAll = coordAll;\nexports.geomEach = geomEach;\nexports.geomReduce = geomReduce;\nexports.flattenEach = flattenEach;\nexports.flattenReduce = flattenReduce;\nexports.segmentEach = segmentEach;\nexports.segmentReduce = segmentReduce;\nexports.lineEach = lineEach;\nexports.lineReduce = lineReduce;\nexports.findSegment = findSegment;\nexports.findPoint = findPoint;\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar helpers_1 = require(\"@turf/helpers\");\r\n/**\r\n * Unwrap a coordinate from a Point Feature, Geometry or a single coordinate.\r\n *\r\n * @name getCoord\r\n * @param {Array<number>|Geometry<Point>|Feature<Point>} coord GeoJSON Point or an Array of numbers\r\n * @returns {Array<number>} coordinates\r\n * @example\r\n * var pt = turf.point([10, 10]);\r\n *\r\n * var coord = turf.getCoord(pt);\r\n * //= [10, 10]\r\n */\r\nfunction getCoord(coord) {\r\n    if (!coord) {\r\n        throw new Error(\"coord is required\");\r\n    }\r\n    if (!Array.isArray(coord)) {\r\n        if (coord.type === \"Feature\" && coord.geometry !== null && coord.geometry.type === \"Point\") {\r\n            return coord.geometry.coordinates;\r\n        }\r\n        if (coord.type === \"Point\") {\r\n            return coord.coordinates;\r\n        }\r\n    }\r\n    if (Array.isArray(coord) && coord.length >= 2 && !Array.isArray(coord[0]) && !Array.isArray(coord[1])) {\r\n        return coord;\r\n    }\r\n    throw new Error(\"coord must be GeoJSON Point or an Array of numbers\");\r\n}\r\nexports.getCoord = getCoord;\r\n/**\r\n * Unwrap coordinates from a Feature, Geometry Object or an Array\r\n *\r\n * @name getCoords\r\n * @param {Array<any>|Geometry|Feature} coords Feature, Geometry Object or an Array\r\n * @returns {Array<any>} coordinates\r\n * @example\r\n * var poly = turf.polygon([[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]);\r\n *\r\n * var coords = turf.getCoords(poly);\r\n * //= [[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]\r\n */\r\nfunction getCoords(coords) {\r\n    if (Array.isArray(coords)) {\r\n        return coords;\r\n    }\r\n    // Feature\r\n    if (coords.type === \"Feature\") {\r\n        if (coords.geometry !== null) {\r\n            return coords.geometry.coordinates;\r\n        }\r\n    }\r\n    else {\r\n        // Geometry\r\n        if (coords.coordinates) {\r\n            return coords.coordinates;\r\n        }\r\n    }\r\n    throw new Error(\"coords must be GeoJSON Feature, Geometry Object or an Array\");\r\n}\r\nexports.getCoords = getCoords;\r\n/**\r\n * Checks if coordinates contains a number\r\n *\r\n * @name containsNumber\r\n * @param {Array<any>} coordinates GeoJSON Coordinates\r\n * @returns {boolean} true if Array contains a number\r\n */\r\nfunction containsNumber(coordinates) {\r\n    if (coordinates.length > 1 && helpers_1.isNumber(coordinates[0]) && helpers_1.isNumber(coordinates[1])) {\r\n        return true;\r\n    }\r\n    if (Array.isArray(coordinates[0]) && coordinates[0].length) {\r\n        return containsNumber(coordinates[0]);\r\n    }\r\n    throw new Error(\"coordinates must only contain numbers\");\r\n}\r\nexports.containsNumber = containsNumber;\r\n/**\r\n * Enforce expectations about types of GeoJSON objects for Turf.\r\n *\r\n * @name geojsonType\r\n * @param {GeoJSON} value any GeoJSON object\r\n * @param {string} type expected GeoJSON type\r\n * @param {string} name name of calling function\r\n * @throws {Error} if value is not the expected type.\r\n */\r\nfunction geojsonType(value, type, name) {\r\n    if (!type || !name) {\r\n        throw new Error(\"type and name required\");\r\n    }\r\n    if (!value || value.type !== type) {\r\n        throw new Error(\"Invalid input to \" + name + \": must be a \" + type + \", given \" + value.type);\r\n    }\r\n}\r\nexports.geojsonType = geojsonType;\r\n/**\r\n * Enforce expectations about types of {@link Feature} inputs for Turf.\r\n * Internally this uses {@link geojsonType} to judge geometry types.\r\n *\r\n * @name featureOf\r\n * @param {Feature} feature a feature with an expected geometry type\r\n * @param {string} type expected GeoJSON type\r\n * @param {string} name name of calling function\r\n * @throws {Error} error if value is not the expected type.\r\n */\r\nfunction featureOf(feature, type, name) {\r\n    if (!feature) {\r\n        throw new Error(\"No feature passed\");\r\n    }\r\n    if (!name) {\r\n        throw new Error(\".featureOf() requires a name\");\r\n    }\r\n    if (!feature || feature.type !== \"Feature\" || !feature.geometry) {\r\n        throw new Error(\"Invalid input to \" + name + \", Feature with geometry required\");\r\n    }\r\n    if (!feature.geometry || feature.geometry.type !== type) {\r\n        throw new Error(\"Invalid input to \" + name + \": must be a \" + type + \", given \" + feature.geometry.type);\r\n    }\r\n}\r\nexports.featureOf = featureOf;\r\n/**\r\n * Enforce expectations about types of {@link FeatureCollection} inputs for Turf.\r\n * Internally this uses {@link geojsonType} to judge geometry types.\r\n *\r\n * @name collectionOf\r\n * @param {FeatureCollection} featureCollection a FeatureCollection for which features will be judged\r\n * @param {string} type expected GeoJSON type\r\n * @param {string} name name of calling function\r\n * @throws {Error} if value is not the expected type.\r\n */\r\nfunction collectionOf(featureCollection, type, name) {\r\n    if (!featureCollection) {\r\n        throw new Error(\"No featureCollection passed\");\r\n    }\r\n    if (!name) {\r\n        throw new Error(\".collectionOf() requires a name\");\r\n    }\r\n    if (!featureCollection || featureCollection.type !== \"FeatureCollection\") {\r\n        throw new Error(\"Invalid input to \" + name + \", FeatureCollection required\");\r\n    }\r\n    for (var _i = 0, _a = featureCollection.features; _i < _a.length; _i++) {\r\n        var feature = _a[_i];\r\n        if (!feature || feature.type !== \"Feature\" || !feature.geometry) {\r\n            throw new Error(\"Invalid input to \" + name + \", Feature with geometry required\");\r\n        }\r\n        if (!feature.geometry || feature.geometry.type !== type) {\r\n            throw new Error(\"Invalid input to \" + name + \": must be a \" + type + \", given \" + feature.geometry.type);\r\n        }\r\n    }\r\n}\r\nexports.collectionOf = collectionOf;\r\n/**\r\n * Get Geometry from Feature or Geometry Object\r\n *\r\n * @param {Feature|Geometry} geojson GeoJSON Feature or Geometry Object\r\n * @returns {Geometry|null} GeoJSON Geometry Object\r\n * @throws {Error} if geojson is not a Feature or Geometry Object\r\n * @example\r\n * var point = {\r\n *   \"type\": \"Feature\",\r\n *   \"properties\": {},\r\n *   \"geometry\": {\r\n *     \"type\": \"Point\",\r\n *     \"coordinates\": [110, 40]\r\n *   }\r\n * }\r\n * var geom = turf.getGeom(point)\r\n * //={\"type\": \"Point\", \"coordinates\": [110, 40]}\r\n */\r\nfunction getGeom(geojson) {\r\n    if (geojson.type === \"Feature\") {\r\n        return geojson.geometry;\r\n    }\r\n    return geojson;\r\n}\r\nexports.getGeom = getGeom;\r\n/**\r\n * Get GeoJSON object's type, Geometry type is prioritize.\r\n *\r\n * @param {GeoJSON} geojson GeoJSON object\r\n * @param {string} [name=\"geojson\"] name of the variable to display in error message\r\n * @returns {string} GeoJSON type\r\n * @example\r\n * var point = {\r\n *   \"type\": \"Feature\",\r\n *   \"properties\": {},\r\n *   \"geometry\": {\r\n *     \"type\": \"Point\",\r\n *     \"coordinates\": [110, 40]\r\n *   }\r\n * }\r\n * var geom = turf.getType(point)\r\n * //=\"Point\"\r\n */\r\nfunction getType(geojson, name) {\r\n    if (geojson.type === \"FeatureCollection\") {\r\n        return \"FeatureCollection\";\r\n    }\r\n    if (geojson.type === \"GeometryCollection\") {\r\n        return \"GeometryCollection\";\r\n    }\r\n    if (geojson.type === \"Feature\" && geojson.geometry !== null) {\r\n        return geojson.geometry.type;\r\n    }\r\n    return geojson.type;\r\n}\r\nexports.getType = getType;\r\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar helpers_1 = require(\"@turf/helpers\");\nvar invariant_1 = require(\"@turf/invariant\");\n// http://en.wikipedia.org/wiki/Haversine_formula\n// http://www.movable-type.co.uk/scripts/latlong.html\n/**\n * Takes two {@link Point|points} and finds the geographic bearing between them,\n * i.e. the angle measured in degrees from the north line (0 degrees)\n *\n * @name bearing\n * @param {Coord} start starting Point\n * @param {Coord} end ending Point\n * @param {Object} [options={}] Optional parameters\n * @param {boolean} [options.final=false] calculates the final bearing if true\n * @returns {number} bearing in decimal degrees, between -180 and 180 degrees (positive clockwise)\n * @example\n * var point1 = turf.point([-75.343, 39.984]);\n * var point2 = turf.point([-75.534, 39.123]);\n *\n * var bearing = turf.bearing(point1, point2);\n *\n * //addToMap\n * var addToMap = [point1, point2]\n * point1.properties['marker-color'] = '#f00'\n * point2.properties['marker-color'] = '#0f0'\n * point1.properties.bearing = bearing\n */\nfunction bearing(start, end, options) {\n    if (options === void 0) { options = {}; }\n    // Reverse calculation\n    if (options.final === true) {\n        return calculateFinalBearing(start, end);\n    }\n    var coordinates1 = invariant_1.getCoord(start);\n    var coordinates2 = invariant_1.getCoord(end);\n    var lon1 = helpers_1.degreesToRadians(coordinates1[0]);\n    var lon2 = helpers_1.degreesToRadians(coordinates2[0]);\n    var lat1 = helpers_1.degreesToRadians(coordinates1[1]);\n    var lat2 = helpers_1.degreesToRadians(coordinates2[1]);\n    var a = Math.sin(lon2 - lon1) * Math.cos(lat2);\n    var b = Math.cos(lat1) * Math.sin(lat2) -\n        Math.sin(lat1) * Math.cos(lat2) * Math.cos(lon2 - lon1);\n    return helpers_1.radiansToDegrees(Math.atan2(a, b));\n}\n/**\n * Calculates Final Bearing\n *\n * @private\n * @param {Coord} start starting Point\n * @param {Coord} end ending Point\n * @returns {number} bearing\n */\nfunction calculateFinalBearing(start, end) {\n    // Swap start & end\n    var bear = bearing(end, start);\n    bear = (bear + 180) % 360;\n    return bear;\n}\nexports.default = bearing;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// http://en.wikipedia.org/wiki/Haversine_formula\n// http://www.movable-type.co.uk/scripts/latlong.html\nvar helpers_1 = require(\"@turf/helpers\");\nvar invariant_1 = require(\"@turf/invariant\");\n/**\n * Takes a {@link Point} and calculates the location of a destination point given a distance in\n * degrees, radians, miles, or kilometers; and bearing in degrees.\n * This uses the [Haversine formula](http://en.wikipedia.org/wiki/Haversine_formula) to account for global curvature.\n *\n * @name destination\n * @param {Coord} origin starting point\n * @param {number} distance distance from the origin point\n * @param {number} bearing ranging from -180 to 180\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.units='kilometers'] miles, kilometers, degrees, or radians\n * @param {Object} [options.properties={}] Translate properties to Point\n * @returns {Feature<Point>} destination point\n * @example\n * var point = turf.point([-75.343, 39.984]);\n * var distance = 50;\n * var bearing = 90;\n * var options = {units: 'miles'};\n *\n * var destination = turf.destination(point, distance, bearing, options);\n *\n * //addToMap\n * var addToMap = [point, destination]\n * destination.properties['marker-color'] = '#f00';\n * point.properties['marker-color'] = '#0f0';\n */\nfunction destination(origin, distance, bearing, options) {\n    if (options === void 0) { options = {}; }\n    // Handle input\n    var coordinates1 = invariant_1.getCoord(origin);\n    var longitude1 = helpers_1.degreesToRadians(coordinates1[0]);\n    var latitude1 = helpers_1.degreesToRadians(coordinates1[1]);\n    var bearingRad = helpers_1.degreesToRadians(bearing);\n    var radians = helpers_1.lengthToRadians(distance, options.units);\n    // Main\n    var latitude2 = Math.asin(Math.sin(latitude1) * Math.cos(radians) +\n        Math.cos(latitude1) * Math.sin(radians) * Math.cos(bearingRad));\n    var longitude2 = longitude1 + Math.atan2(Math.sin(bearingRad) * Math.sin(radians) * Math.cos(latitude1), Math.cos(radians) - Math.sin(latitude1) * Math.sin(latitude2));\n    var lng = helpers_1.radiansToDegrees(longitude2);\n    var lat = helpers_1.radiansToDegrees(latitude2);\n    return helpers_1.point([lng, lat], options.properties);\n}\nexports.default = destination;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar invariant_1 = require(\"@turf/invariant\");\nvar helpers_1 = require(\"@turf/helpers\");\n//http://en.wikipedia.org/wiki/Haversine_formula\n//http://www.movable-type.co.uk/scripts/latlong.html\n/**\n * Calculates the distance between two {@link Point|points} in degrees, radians, miles, or kilometers.\n * This uses the [Haversine formula](http://en.wikipedia.org/wiki/Haversine_formula) to account for global curvature.\n *\n * @name distance\n * @param {Coord} from origin point\n * @param {Coord} to destination point\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.units='kilometers'] can be degrees, radians, miles, or kilometers\n * @returns {number} distance between the two points\n * @example\n * var from = turf.point([-75.343, 39.984]);\n * var to = turf.point([-75.534, 39.123]);\n * var options = {units: 'miles'};\n *\n * var distance = turf.distance(from, to, options);\n *\n * //addToMap\n * var addToMap = [from, to];\n * from.properties.distance = distance;\n * to.properties.distance = distance;\n */\nfunction distance(from, to, options) {\n    if (options === void 0) { options = {}; }\n    var coordinates1 = invariant_1.getCoord(from);\n    var coordinates2 = invariant_1.getCoord(to);\n    var dLat = helpers_1.degreesToRadians((coordinates2[1] - coordinates1[1]));\n    var dLon = helpers_1.degreesToRadians((coordinates2[0] - coordinates1[0]));\n    var lat1 = helpers_1.degreesToRadians(coordinates1[1]);\n    var lat2 = helpers_1.degreesToRadians(coordinates2[1]);\n    var a = Math.pow(Math.sin(dLat / 2), 2) +\n        Math.pow(Math.sin(dLon / 2), 2) * Math.cos(lat1) * Math.cos(lat2);\n    return helpers_1.radiansToLength(2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)), options.units);\n}\nexports.default = distance;\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar bearing_1 = __importDefault(require(\"@turf/bearing\"));\nvar destination_1 = __importDefault(require(\"@turf/destination\"));\nvar distance_1 = __importDefault(require(\"@turf/distance\"));\nvar helpers_1 = require(\"@turf/helpers\");\nvar invariant_1 = require(\"@turf/invariant\");\n/**\n * Takes a {@link LineString} and returns a {@link Point} at a specified distance along the line.\n *\n * @name along\n * @param {Feature<LineString>} line input line\n * @param {number} distance distance along the line\n * @param {Object} [options] Optional parameters\n * @param {string} [options.units=\"kilometers\"] can be degrees, radians, miles, or kilometers\n * @returns {Feature<Point>} Point `distance` `units` along the line\n * @example\n * var line = turf.lineString([[-83, 30], [-84, 36], [-78, 41]]);\n * var options = {units: 'miles'};\n *\n * var along = turf.along(line, 200, options);\n *\n * //addToMap\n * var addToMap = [along, line]\n */\nfunction along(line, distance, options) {\n    if (options === void 0) { options = {}; }\n    // Get Coords\n    var geom = invariant_1.getGeom(line);\n    var coords = geom.coordinates;\n    var travelled = 0;\n    for (var i = 0; i < coords.length; i++) {\n        if (distance >= travelled && i === coords.length - 1) {\n            break;\n        }\n        else if (travelled >= distance) {\n            var overshot = distance - travelled;\n            if (!overshot) {\n                return helpers_1.point(coords[i]);\n            }\n            else {\n                var direction = bearing_1.default(coords[i], coords[i - 1]) - 180;\n                var interpolated = destination_1.default(coords[i], overshot, direction, options);\n                return interpolated;\n            }\n        }\n        else {\n            travelled += distance_1.default(coords[i], coords[i + 1], options);\n        }\n    }\n    return helpers_1.point(coords[coords.length - 1]);\n}\nexports.default = along;\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar distance_1 = __importDefault(require(\"@turf/distance\"));\nvar meta_1 = require(\"@turf/meta\");\n/**\n * Takes a {@link GeoJSON} and measures its length in the specified units, {@link (Multi)Point}'s distance are ignored.\n *\n * @name length\n * @param {Feature<LineString|MultiLineString>} geojson GeoJSON to measure\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.units=kilometers] can be degrees, radians, miles, or kilometers\n * @returns {number} length of GeoJSON\n * @example\n * var line = turf.lineString([[115, -32], [131, -22], [143, -25], [150, -34]]);\n * var length = turf.length(line, {units: 'miles'});\n *\n * //addToMap\n * var addToMap = [line];\n * line.properties.distance = length;\n */\nfunction length(geojson, options) {\n    if (options === void 0) { options = {}; }\n    // Calculate distance from 2-vertex line segments\n    return meta_1.segmentReduce(geojson, function (previousValue, segment) {\n        var coords = segment.geometry.coordinates;\n        return previousValue + distance_1.default(coords[0], coords[1], options);\n    }, 0);\n}\nexports.default = length;\n","export default function _isPlaceholder(a) {\n  return a != null && typeof a === 'object' && a['@@functional/placeholder'] === true;\n}","import _isPlaceholder from \"./_isPlaceholder.js\";\n/**\n * Optimized internal one-arity curry function.\n *\n * @private\n * @category Function\n * @param {Function} fn The function to curry.\n * @return {Function} The curried function.\n */\n\nexport default function _curry1(fn) {\n  return function f1(a) {\n    if (arguments.length === 0 || _isPlaceholder(a)) {\n      return f1;\n    } else {\n      return fn.apply(this, arguments);\n    }\n  };\n}","import _curry1 from \"./_curry1.js\";\nimport _isPlaceholder from \"./_isPlaceholder.js\";\n/**\n * Optimized internal two-arity curry function.\n *\n * @private\n * @category Function\n * @param {Function} fn The function to curry.\n * @return {Function} The curried function.\n */\n\nexport default function _curry2(fn) {\n  return function f2(a, b) {\n    switch (arguments.length) {\n      case 0:\n        return f2;\n\n      case 1:\n        return _isPlaceholder(a) ? f2 : _curry1(function (_b) {\n          return fn(a, _b);\n        });\n\n      default:\n        return _isPlaceholder(a) && _isPlaceholder(b) ? f2 : _isPlaceholder(a) ? _curry1(function (_a) {\n          return fn(_a, b);\n        }) : _isPlaceholder(b) ? _curry1(function (_b) {\n          return fn(a, _b);\n        }) : fn(a, b);\n    }\n  };\n}","import _curry2 from \"./internal/_curry2.js\";\n/**\n * Adds two values.\n *\n * @func\n * @memberOf R\n * @since v0.1.0\n * @category Math\n * @sig Number -> Number -> Number\n * @param {Number} a\n * @param {Number} b\n * @return {Number}\n * @see R.subtract\n * @example\n *\n *      R.add(2, 3);       //=>  5\n *      R.add(7)(10);      //=> 17\n */\n\nvar add =\n/*#__PURE__*/\n_curry2(function add(a, b) {\n  return Number(a) + Number(b);\n});\n\nexport default add;","export default function _arity(n, fn) {\n  /* eslint-disable no-unused-vars */\n  switch (n) {\n    case 0:\n      return function () {\n        return fn.apply(this, arguments);\n      };\n\n    case 1:\n      return function (a0) {\n        return fn.apply(this, arguments);\n      };\n\n    case 2:\n      return function (a0, a1) {\n        return fn.apply(this, arguments);\n      };\n\n    case 3:\n      return function (a0, a1, a2) {\n        return fn.apply(this, arguments);\n      };\n\n    case 4:\n      return function (a0, a1, a2, a3) {\n        return fn.apply(this, arguments);\n      };\n\n    case 5:\n      return function (a0, a1, a2, a3, a4) {\n        return fn.apply(this, arguments);\n      };\n\n    case 6:\n      return function (a0, a1, a2, a3, a4, a5) {\n        return fn.apply(this, arguments);\n      };\n\n    case 7:\n      return function (a0, a1, a2, a3, a4, a5, a6) {\n        return fn.apply(this, arguments);\n      };\n\n    case 8:\n      return function (a0, a1, a2, a3, a4, a5, a6, a7) {\n        return fn.apply(this, arguments);\n      };\n\n    case 9:\n      return function (a0, a1, a2, a3, a4, a5, a6, a7, a8) {\n        return fn.apply(this, arguments);\n      };\n\n    case 10:\n      return function (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) {\n        return fn.apply(this, arguments);\n      };\n\n    default:\n      throw new Error('First argument to _arity must be a non-negative integer no greater than ten');\n  }\n}","import _arity from \"./_arity.js\";\nimport _isPlaceholder from \"./_isPlaceholder.js\";\n/**\n * Internal curryN function.\n *\n * @private\n * @category Function\n * @param {Number} length The arity of the curried function.\n * @param {Array} received An array of arguments received thus far.\n * @param {Function} fn The function to curry.\n * @return {Function} The curried function.\n */\n\nexport default function _curryN(length, received, fn) {\n  return function () {\n    var combined = [];\n    var argsIdx = 0;\n    var left = length;\n    var combinedIdx = 0;\n\n    while (combinedIdx < received.length || argsIdx < arguments.length) {\n      var result;\n\n      if (combinedIdx < received.length && (!_isPlaceholder(received[combinedIdx]) || argsIdx >= arguments.length)) {\n        result = received[combinedIdx];\n      } else {\n        result = arguments[argsIdx];\n        argsIdx += 1;\n      }\n\n      combined[combinedIdx] = result;\n\n      if (!_isPlaceholder(result)) {\n        left -= 1;\n      }\n\n      combinedIdx += 1;\n    }\n\n    return left <= 0 ? fn.apply(this, combined) : _arity(left, _curryN(length, combined, fn));\n  };\n}","import _arity from \"./internal/_arity.js\";\nimport _curry1 from \"./internal/_curry1.js\";\nimport _curry2 from \"./internal/_curry2.js\";\nimport _curryN from \"./internal/_curryN.js\";\n/**\n * Returns a curried equivalent of the provided function, with the specified\n * arity. The curried function has two unusual capabilities. First, its\n * arguments needn't be provided one at a time. If `g` is `R.curryN(3, f)`, the\n * following are equivalent:\n *\n *   - `g(1)(2)(3)`\n *   - `g(1)(2, 3)`\n *   - `g(1, 2)(3)`\n *   - `g(1, 2, 3)`\n *\n * Secondly, the special placeholder value [`R.__`](#__) may be used to specify\n * \"gaps\", allowing partial application of any combination of arguments,\n * regardless of their positions. If `g` is as above and `_` is [`R.__`](#__),\n * the following are equivalent:\n *\n *   - `g(1, 2, 3)`\n *   - `g(_, 2, 3)(1)`\n *   - `g(_, _, 3)(1)(2)`\n *   - `g(_, _, 3)(1, 2)`\n *   - `g(_, 2)(1)(3)`\n *   - `g(_, 2)(1, 3)`\n *   - `g(_, 2)(_, 3)(1)`\n *\n * @func\n * @memberOf R\n * @since v0.5.0\n * @category Function\n * @sig Number -> (* -> a) -> (* -> a)\n * @param {Number} length The arity for the returned function.\n * @param {Function} fn The function to curry.\n * @return {Function} A new, curried function.\n * @see R.curry\n * @example\n *\n *      const sumArgs = (...args) => R.sum(args);\n *\n *      const curriedAddFourNumbers = R.curryN(4, sumArgs);\n *      const f = curriedAddFourNumbers(1, 2);\n *      const g = f(3);\n *      g(4); //=> 10\n */\n\nvar curryN =\n/*#__PURE__*/\n_curry2(function curryN(length, fn) {\n  if (length === 1) {\n    return _curry1(fn);\n  }\n\n  return _arity(length, _curryN(length, [], fn));\n});\n\nexport default curryN;","import _curry1 from \"./_curry1.js\";\nimport _curry2 from \"./_curry2.js\";\nimport _isPlaceholder from \"./_isPlaceholder.js\";\n/**\n * Optimized internal three-arity curry function.\n *\n * @private\n * @category Function\n * @param {Function} fn The function to curry.\n * @return {Function} The curried function.\n */\n\nexport default function _curry3(fn) {\n  return function f3(a, b, c) {\n    switch (arguments.length) {\n      case 0:\n        return f3;\n\n      case 1:\n        return _isPlaceholder(a) ? f3 : _curry2(function (_b, _c) {\n          return fn(a, _b, _c);\n        });\n\n      case 2:\n        return _isPlaceholder(a) && _isPlaceholder(b) ? f3 : _isPlaceholder(a) ? _curry2(function (_a, _c) {\n          return fn(_a, b, _c);\n        }) : _isPlaceholder(b) ? _curry2(function (_b, _c) {\n          return fn(a, _b, _c);\n        }) : _curry1(function (_c) {\n          return fn(a, b, _c);\n        });\n\n      default:\n        return _isPlaceholder(a) && _isPlaceholder(b) && _isPlaceholder(c) ? f3 : _isPlaceholder(a) && _isPlaceholder(b) ? _curry2(function (_a, _b) {\n          return fn(_a, _b, c);\n        }) : _isPlaceholder(a) && _isPlaceholder(c) ? _curry2(function (_a, _c) {\n          return fn(_a, b, _c);\n        }) : _isPlaceholder(b) && _isPlaceholder(c) ? _curry2(function (_b, _c) {\n          return fn(a, _b, _c);\n        }) : _isPlaceholder(a) ? _curry1(function (_a) {\n          return fn(_a, b, c);\n        }) : _isPlaceholder(b) ? _curry1(function (_b) {\n          return fn(a, _b, c);\n        }) : _isPlaceholder(c) ? _curry1(function (_c) {\n          return fn(a, b, _c);\n        }) : fn(a, b, c);\n    }\n  };\n}","/**\n * Tests whether or not an object is an array.\n *\n * @private\n * @param {*} val The object to test.\n * @return {Boolean} `true` if `val` is an array, `false` otherwise.\n * @example\n *\n *      _isArray([]); //=> true\n *      _isArray(null); //=> false\n *      _isArray({}); //=> false\n */\nexport default Array.isArray || function _isArray(val) {\n  return val != null && val.length >= 0 && Object.prototype.toString.call(val) === '[object Array]';\n};","export default function _isTransformer(obj) {\n  return obj != null && typeof obj['@@transducer/step'] === 'function';\n}","import _isArray from \"./_isArray.js\";\nimport _isTransformer from \"./_isTransformer.js\";\n/**\n * Returns a function that dispatches with different strategies based on the\n * object in list position (last argument). If it is an array, executes [fn].\n * Otherwise, if it has a function with one of the given method names, it will\n * execute that function (functor case). Otherwise, if it is a transformer,\n * uses transducer [xf] to return a new transformer (transducer case).\n * Otherwise, it will default to executing [fn].\n *\n * @private\n * @param {Array} methodNames properties to check for a custom implementation\n * @param {Function} xf transducer to initialize if object is transformer\n * @param {Function} fn default ramda implementation\n * @return {Function} A function that dispatches on object in list position\n */\n\nexport default function _dispatchable(methodNames, xf, fn) {\n  return function () {\n    if (arguments.length === 0) {\n      return fn();\n    }\n\n    var args = Array.prototype.slice.call(arguments, 0);\n    var obj = args.pop();\n\n    if (!_isArray(obj)) {\n      var idx = 0;\n\n      while (idx < methodNames.length) {\n        if (typeof obj[methodNames[idx]] === 'function') {\n          return obj[methodNames[idx]].apply(obj, args);\n        }\n\n        idx += 1;\n      }\n\n      if (_isTransformer(obj)) {\n        var transducer = xf.apply(null, args);\n        return transducer(obj);\n      }\n    }\n\n    return fn.apply(this, arguments);\n  };\n}","export default {\n  init: function () {\n    return this.xf['@@transducer/init']();\n  },\n  result: function (result) {\n    return this.xf['@@transducer/result'](result);\n  }\n};","export default function _isString(x) {\n  return Object.prototype.toString.call(x) === '[object String]';\n}","import _curry1 from \"./_curry1.js\";\nimport _isArray from \"./_isArray.js\";\nimport _isString from \"./_isString.js\";\n/**\n * Tests whether or not an object is similar to an array.\n *\n * @private\n * @category Type\n * @category List\n * @sig * -> Boolean\n * @param {*} x The object to test.\n * @return {Boolean} `true` if `x` has a numeric length property and extreme indices defined; `false` otherwise.\n * @example\n *\n *      _isArrayLike([]); //=> true\n *      _isArrayLike(true); //=> false\n *      _isArrayLike({}); //=> false\n *      _isArrayLike({length: 10}); //=> false\n *      _isArrayLike({0: 'zero', 9: 'nine', length: 10}); //=> true\n */\n\nvar _isArrayLike =\n/*#__PURE__*/\n_curry1(function isArrayLike(x) {\n  if (_isArray(x)) {\n    return true;\n  }\n\n  if (!x) {\n    return false;\n  }\n\n  if (typeof x !== 'object') {\n    return false;\n  }\n\n  if (_isString(x)) {\n    return false;\n  }\n\n  if (x.nodeType === 1) {\n    return !!x.length;\n  }\n\n  if (x.length === 0) {\n    return true;\n  }\n\n  if (x.length > 0) {\n    return x.hasOwnProperty(0) && x.hasOwnProperty(x.length - 1);\n  }\n\n  return false;\n});\n\nexport default _isArrayLike;","var XWrap =\n/*#__PURE__*/\nfunction () {\n  function XWrap(fn) {\n    this.f = fn;\n  }\n\n  XWrap.prototype['@@transducer/init'] = function () {\n    throw new Error('init not implemented on XWrap');\n  };\n\n  XWrap.prototype['@@transducer/result'] = function (acc) {\n    return acc;\n  };\n\n  XWrap.prototype['@@transducer/step'] = function (acc, x) {\n    return this.f(acc, x);\n  };\n\n  return XWrap;\n}();\n\nexport default function _xwrap(fn) {\n  return new XWrap(fn);\n}","import _arity from \"./internal/_arity.js\";\nimport _curry2 from \"./internal/_curry2.js\";\n/**\n * Creates a function that is bound to a context.\n * Note: `R.bind` does not provide the additional argument-binding capabilities of\n * [Function.prototype.bind](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind).\n *\n * @func\n * @memberOf R\n * @since v0.6.0\n * @category Function\n * @category Object\n * @sig (* -> *) -> {*} -> (* -> *)\n * @param {Function} fn The function to bind to context\n * @param {Object} thisObj The context to bind `fn` to\n * @return {Function} A function that will execute in the context of `thisObj`.\n * @see R.partial\n * @example\n *\n *      const log = R.bind(console.log, console);\n *      R.pipe(R.assoc('a', 2), R.tap(log), R.assoc('a', 3))({a: 1}); //=> {a: 3}\n *      // logs {a: 2}\n * @symb R.bind(f, o)(a, b) = f.call(o, a, b)\n */\n\nvar bind =\n/*#__PURE__*/\n_curry2(function bind(fn, thisObj) {\n  return _arity(fn.length, function () {\n    return fn.apply(thisObj, arguments);\n  });\n});\n\nexport default bind;","import _isArrayLike from \"./_isArrayLike.js\";\nimport _xwrap from \"./_xwrap.js\";\nimport bind from \"../bind.js\";\n\nfunction _arrayReduce(xf, acc, list) {\n  var idx = 0;\n  var len = list.length;\n\n  while (idx < len) {\n    acc = xf['@@transducer/step'](acc, list[idx]);\n\n    if (acc && acc['@@transducer/reduced']) {\n      acc = acc['@@transducer/value'];\n      break;\n    }\n\n    idx += 1;\n  }\n\n  return xf['@@transducer/result'](acc);\n}\n\nfunction _iterableReduce(xf, acc, iter) {\n  var step = iter.next();\n\n  while (!step.done) {\n    acc = xf['@@transducer/step'](acc, step.value);\n\n    if (acc && acc['@@transducer/reduced']) {\n      acc = acc['@@transducer/value'];\n      break;\n    }\n\n    step = iter.next();\n  }\n\n  return xf['@@transducer/result'](acc);\n}\n\nfunction _methodReduce(xf, acc, obj, methodName) {\n  return xf['@@transducer/result'](obj[methodName](bind(xf['@@transducer/step'], xf), acc));\n}\n\nvar symIterator = typeof Symbol !== 'undefined' ? Symbol.iterator : '@@iterator';\nexport default function _reduce(fn, acc, list) {\n  if (typeof fn === 'function') {\n    fn = _xwrap(fn);\n  }\n\n  if (_isArrayLike(list)) {\n    return _arrayReduce(fn, acc, list);\n  }\n\n  if (typeof list['fantasy-land/reduce'] === 'function') {\n    return _methodReduce(fn, acc, list, 'fantasy-land/reduce');\n  }\n\n  if (list[symIterator] != null) {\n    return _iterableReduce(fn, acc, list[symIterator]());\n  }\n\n  if (typeof list.next === 'function') {\n    return _iterableReduce(fn, acc, list);\n  }\n\n  if (typeof list.reduce === 'function') {\n    return _methodReduce(fn, acc, list, 'reduce');\n  }\n\n  throw new TypeError('reduce: list must be array or iterable');\n}","import _curry2 from \"./_curry2.js\";\nimport _xfBase from \"./_xfBase.js\";\n\nvar XMap =\n/*#__PURE__*/\nfunction () {\n  function XMap(f, xf) {\n    this.xf = xf;\n    this.f = f;\n  }\n\n  XMap.prototype['@@transducer/init'] = _xfBase.init;\n  XMap.prototype['@@transducer/result'] = _xfBase.result;\n\n  XMap.prototype['@@transducer/step'] = function (result, input) {\n    return this.xf['@@transducer/step'](result, this.f(input));\n  };\n\n  return XMap;\n}();\n\nvar _xmap =\n/*#__PURE__*/\n_curry2(function _xmap(f, xf) {\n  return new XMap(f, xf);\n});\n\nexport default _xmap;","export default function _has(prop, obj) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}","import _has from \"./_has.js\";\nvar toString = Object.prototype.toString;\n\nvar _isArguments =\n/*#__PURE__*/\nfunction () {\n  return toString.call(arguments) === '[object Arguments]' ? function _isArguments(x) {\n    return toString.call(x) === '[object Arguments]';\n  } : function _isArguments(x) {\n    return _has('callee', x);\n  };\n}();\n\nexport default _isArguments;","import _curry1 from \"./internal/_curry1.js\";\nimport _has from \"./internal/_has.js\";\nimport _isArguments from \"./internal/_isArguments.js\"; // cover IE < 9 keys issues\n\nvar hasEnumBug = !\n/*#__PURE__*/\n{\n  toString: null\n}.propertyIsEnumerable('toString');\nvar nonEnumerableProps = ['constructor', 'valueOf', 'isPrototypeOf', 'toString', 'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString']; // Safari bug\n\nvar hasArgsEnumBug =\n/*#__PURE__*/\nfunction () {\n  'use strict';\n\n  return arguments.propertyIsEnumerable('length');\n}();\n\nvar contains = function contains(list, item) {\n  var idx = 0;\n\n  while (idx < list.length) {\n    if (list[idx] === item) {\n      return true;\n    }\n\n    idx += 1;\n  }\n\n  return false;\n};\n/**\n * Returns a list containing the names of all the enumerable own properties of\n * the supplied object.\n * Note that the order of the output array is not guaranteed to be consistent\n * across different JS platforms.\n *\n * @func\n * @memberOf R\n * @since v0.1.0\n * @category Object\n * @sig {k: v} -> [k]\n * @param {Object} obj The object to extract properties from\n * @return {Array} An array of the object's own properties.\n * @see R.keysIn, R.values\n * @example\n *\n *      R.keys({a: 1, b: 2, c: 3}); //=> ['a', 'b', 'c']\n */\n\n\nvar keys = typeof Object.keys === 'function' && !hasArgsEnumBug ?\n/*#__PURE__*/\n_curry1(function keys(obj) {\n  return Object(obj) !== obj ? [] : Object.keys(obj);\n}) :\n/*#__PURE__*/\n_curry1(function keys(obj) {\n  if (Object(obj) !== obj) {\n    return [];\n  }\n\n  var prop, nIdx;\n  var ks = [];\n\n  var checkArgsLength = hasArgsEnumBug && _isArguments(obj);\n\n  for (prop in obj) {\n    if (_has(prop, obj) && (!checkArgsLength || prop !== 'length')) {\n      ks[ks.length] = prop;\n    }\n  }\n\n  if (hasEnumBug) {\n    nIdx = nonEnumerableProps.length - 1;\n\n    while (nIdx >= 0) {\n      prop = nonEnumerableProps[nIdx];\n\n      if (_has(prop, obj) && !contains(ks, prop)) {\n        ks[ks.length] = prop;\n      }\n\n      nIdx -= 1;\n    }\n  }\n\n  return ks;\n});\nexport default keys;","import _curry2 from \"./internal/_curry2.js\";\nimport _dispatchable from \"./internal/_dispatchable.js\";\nimport _map from \"./internal/_map.js\";\nimport _reduce from \"./internal/_reduce.js\";\nimport _xmap from \"./internal/_xmap.js\";\nimport curryN from \"./curryN.js\";\nimport keys from \"./keys.js\";\n/**\n * Takes a function and\n * a [functor](https://github.com/fantasyland/fantasy-land#functor),\n * applies the function to each of the functor's values, and returns\n * a functor of the same shape.\n *\n * Ramda provides suitable `map` implementations for `Array` and `Object`,\n * so this function may be applied to `[1, 2, 3]` or `{x: 1, y: 2, z: 3}`.\n *\n * Dispatches to the `map` method of the second argument, if present.\n *\n * Acts as a transducer if a transformer is given in list position.\n *\n * Also treats functions as functors and will compose them together.\n *\n * @func\n * @memberOf R\n * @since v0.1.0\n * @category List\n * @sig Functor f => (a -> b) -> f a -> f b\n * @param {Function} fn The function to be called on every element of the input `list`.\n * @param {Array} list The list to be iterated over.\n * @return {Array} The new list.\n * @see R.transduce, R.addIndex\n * @example\n *\n *      const double = x => x * 2;\n *\n *      R.map(double, [1, 2, 3]); //=> [2, 4, 6]\n *\n *      R.map(double, {x: 1, y: 2, z: 3}); //=> {x: 2, y: 4, z: 6}\n * @symb R.map(f, [a, b]) = [f(a), f(b)]\n * @symb R.map(f, { x: a, y: b }) = { x: f(a), y: f(b) }\n * @symb R.map(f, functor_o) = functor_o.map(f)\n */\n\nvar map =\n/*#__PURE__*/\n_curry2(\n/*#__PURE__*/\n_dispatchable(['fantasy-land/map', 'map'], _xmap, function map(fn, functor) {\n  switch (Object.prototype.toString.call(functor)) {\n    case '[object Function]':\n      return curryN(functor.length, function () {\n        return fn.call(this, functor.apply(this, arguments));\n      });\n\n    case '[object Object]':\n      return _reduce(function (acc, key) {\n        acc[key] = fn(functor[key]);\n        return acc;\n      }, {}, keys(functor));\n\n    default:\n      return _map(fn, functor);\n  }\n}));\n\nexport default map;","export default function _map(fn, functor) {\n  var idx = 0;\n  var len = functor.length;\n  var result = Array(len);\n\n  while (idx < len) {\n    result[idx] = fn(functor[idx]);\n    idx += 1;\n  }\n\n  return result;\n}","/**\n * Determine if the passed argument is an integer.\n *\n * @private\n * @param {*} n\n * @category Type\n * @return {Boolean}\n */\nexport default Number.isInteger || function _isInteger(n) {\n  return n << 0 === n;\n};","import _curry2 from \"./internal/_curry2.js\";\nimport _isString from \"./internal/_isString.js\";\n/**\n * Returns the nth element of the given list or string. If n is negative the\n * element at index length + n is returned.\n *\n * @func\n * @memberOf R\n * @since v0.1.0\n * @category List\n * @sig Number -> [a] -> a | Undefined\n * @sig Number -> String -> String\n * @param {Number} offset\n * @param {*} list\n * @return {*}\n * @example\n *\n *      const list = ['foo', 'bar', 'baz', 'quux'];\n *      R.nth(1, list); //=> 'bar'\n *      R.nth(-1, list); //=> 'quux'\n *      R.nth(-99, list); //=> undefined\n *\n *      R.nth(2, 'abc'); //=> 'c'\n *      R.nth(3, 'abc'); //=> ''\n * @symb R.nth(-1, [a, b, c]) = c\n * @symb R.nth(0, [a, b, c]) = a\n * @symb R.nth(1, [a, b, c]) = b\n */\n\nvar nth =\n/*#__PURE__*/\n_curry2(function nth(offset, list) {\n  var idx = offset < 0 ? list.length + offset : offset;\n  return _isString(list) ? list.charAt(idx) : list[idx];\n});\n\nexport default nth;","import _curry2 from \"./internal/_curry2.js\";\nimport _isInteger from \"./internal/_isInteger.js\";\nimport nth from \"./nth.js\";\n/**\n * Retrieves the values at given paths of an object.\n *\n * @func\n * @memberOf R\n * @since v0.27.1\n * @category Object\n * @typedefn Idx = [String | Int]\n * @sig [Idx] -> {a} -> [a | Undefined]\n * @param {Array} pathsArray The array of paths to be fetched.\n * @param {Object} obj The object to retrieve the nested properties from.\n * @return {Array} A list consisting of values at paths specified by \"pathsArray\".\n * @see R.path\n * @example\n *\n *      R.paths([['a', 'b'], ['p', 0, 'q']], {a: {b: 2}, p: [{q: 3}]}); //=> [2, 3]\n *      R.paths([['a', 'b'], ['p', 'r']], {a: {b: 2}, p: [{q: 3}]}); //=> [2, undefined]\n */\n\nvar paths =\n/*#__PURE__*/\n_curry2(function paths(pathsArray, obj) {\n  return pathsArray.map(function (paths) {\n    var val = obj;\n    var idx = 0;\n    var p;\n\n    while (idx < paths.length) {\n      if (val == null) {\n        return;\n      }\n\n      p = paths[idx];\n      val = _isInteger(p) ? nth(p, val) : val[p];\n      idx += 1;\n    }\n\n    return val;\n  });\n});\n\nexport default paths;","import _curry2 from \"./internal/_curry2.js\";\nimport paths from \"./paths.js\";\n/**\n * Retrieve the value at a given path.\n *\n * @func\n * @memberOf R\n * @since v0.2.0\n * @category Object\n * @typedefn Idx = String | Int\n * @sig [Idx] -> {a} -> a | Undefined\n * @param {Array} path The path to use.\n * @param {Object} obj The object to retrieve the nested property from.\n * @return {*} The data at `path`.\n * @see R.prop, R.nth\n * @example\n *\n *      R.path(['a', 'b'], {a: {b: 2}}); //=> 2\n *      R.path(['a', 'b'], {c: {b: 2}}); //=> undefined\n *      R.path(['a', 'b', 0], {a: {b: [1, 2, 3]}}); //=> 1\n *      R.path(['a', 'b', -2], {a: {b: [1, 2, 3]}}); //=> 2\n */\n\nvar path =\n/*#__PURE__*/\n_curry2(function path(pathAr, obj) {\n  return paths([pathAr], obj)[0];\n});\n\nexport default path;","import _curry2 from \"./internal/_curry2.js\";\nimport path from \"./path.js\";\n/**\n * Returns a function that when supplied an object returns the indicated\n * property of that object, if it exists.\n *\n * @func\n * @memberOf R\n * @since v0.1.0\n * @category Object\n * @typedefn Idx = String | Int\n * @sig Idx -> {s: a} -> a | Undefined\n * @param {String|Number} p The property name or array index\n * @param {Object} obj The object to query\n * @return {*} The value at `obj.p`.\n * @see R.path, R.nth\n * @example\n *\n *      R.prop('x', {x: 100}); //=> 100\n *      R.prop('x', {}); //=> undefined\n *      R.prop(0, [100]); //=> 100\n *      R.compose(R.inc, R.prop('x'))({ x: 3 }) //=> 4\n */\n\nvar prop =\n/*#__PURE__*/\n_curry2(function prop(p, obj) {\n  return path([p], obj);\n});\n\nexport default prop;","import _curry3 from \"./internal/_curry3.js\";\nimport _reduce from \"./internal/_reduce.js\";\n/**\n * Returns a single item by iterating through the list, successively calling\n * the iterator function and passing it an accumulator value and the current\n * value from the array, and then passing the result to the next call.\n *\n * The iterator function receives two values: *(acc, value)*. It may use\n * [`R.reduced`](#reduced) to shortcut the iteration.\n *\n * The arguments' order of [`reduceRight`](#reduceRight)'s iterator function\n * is *(value, acc)*.\n *\n * Note: `R.reduce` does not skip deleted or unassigned indices (sparse\n * arrays), unlike the native `Array.prototype.reduce` method. For more details\n * on this behavior, see:\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce#Description\n *\n * Dispatches to the `reduce` method of the third argument, if present. When\n * doing so, it is up to the user to handle the [`R.reduced`](#reduced)\n * shortcuting, as this is not implemented by `reduce`.\n *\n * @func\n * @memberOf R\n * @since v0.1.0\n * @category List\n * @sig ((a, b) -> a) -> a -> [b] -> a\n * @param {Function} fn The iterator function. Receives two values, the accumulator and the\n *        current element from the array.\n * @param {*} acc The accumulator value.\n * @param {Array} list The list to iterate over.\n * @return {*} The final, accumulated value.\n * @see R.reduced, R.addIndex, R.reduceRight\n * @example\n *\n *      R.reduce(R.subtract, 0, [1, 2, 3, 4]) // => ((((0 - 1) - 2) - 3) - 4) = -10\n *      //          -               -10\n *      //         / \\              / \\\n *      //        -   4           -6   4\n *      //       / \\              / \\\n *      //      -   3   ==>     -3   3\n *      //     / \\              / \\\n *      //    -   2           -1   2\n *      //   / \\              / \\\n *      //  0   1            0   1\n *\n * @symb R.reduce(f, a, [b, c, d]) = f(f(f(a, b), c), d)\n */\n\nvar reduce =\n/*#__PURE__*/\n_curry3(_reduce);\n\nexport default reduce;","import _curry1 from \"./internal/_curry1.js\";\nimport curryN from \"./curryN.js\";\n/**\n * Returns a curried equivalent of the provided function. The curried function\n * has two unusual capabilities. First, its arguments needn't be provided one\n * at a time. If `f` is a ternary function and `g` is `R.curry(f)`, the\n * following are equivalent:\n *\n *   - `g(1)(2)(3)`\n *   - `g(1)(2, 3)`\n *   - `g(1, 2)(3)`\n *   - `g(1, 2, 3)`\n *\n * Secondly, the special placeholder value [`R.__`](#__) may be used to specify\n * \"gaps\", allowing partial application of any combination of arguments,\n * regardless of their positions. If `g` is as above and `_` is [`R.__`](#__),\n * the following are equivalent:\n *\n *   - `g(1, 2, 3)`\n *   - `g(_, 2, 3)(1)`\n *   - `g(_, _, 3)(1)(2)`\n *   - `g(_, _, 3)(1, 2)`\n *   - `g(_, 2)(1)(3)`\n *   - `g(_, 2)(1, 3)`\n *   - `g(_, 2)(_, 3)(1)`\n *\n * @func\n * @memberOf R\n * @since v0.1.0\n * @category Function\n * @sig (* -> a) -> (* -> a)\n * @param {Function} fn The function to curry.\n * @return {Function} A new, curried function.\n * @see R.curryN, R.partial\n * @example\n *\n *      const addFourNumbers = (a, b, c, d) => a + b + c + d;\n *\n *      const curriedAddFourNumbers = R.curry(addFourNumbers);\n *      const f = curriedAddFourNumbers(1, 2);\n *      const g = f(3);\n *      g(4); //=> 10\n */\n\nvar curry =\n/*#__PURE__*/\n_curry1(function curry(fn) {\n  return curryN(fn.length, fn);\n});\n\nexport default curry;","export default function _pipe(f, g) {\n  return function () {\n    return g.call(this, f.apply(this, arguments));\n  };\n}","import _isArray from \"./_isArray.js\";\n/**\n * This checks whether a function has a [methodname] function. If it isn't an\n * array it will execute that function otherwise it will default to the ramda\n * implementation.\n *\n * @private\n * @param {Function} fn ramda implemtation\n * @param {String} methodname property to check for a custom implementation\n * @return {Object} Whatever the return value of the method is.\n */\n\nexport default function _checkForMethod(methodname, fn) {\n  return function () {\n    var length = arguments.length;\n\n    if (length === 0) {\n      return fn();\n    }\n\n    var obj = arguments[length - 1];\n    return _isArray(obj) || typeof obj[methodname] !== 'function' ? fn.apply(this, arguments) : obj[methodname].apply(obj, Array.prototype.slice.call(arguments, 0, length - 1));\n  };\n}","import _checkForMethod from \"./internal/_checkForMethod.js\";\nimport _curry3 from \"./internal/_curry3.js\";\n/**\n * Returns the elements of the given list or string (or object with a `slice`\n * method) from `fromIndex` (inclusive) to `toIndex` (exclusive).\n *\n * Dispatches to the `slice` method of the third argument, if present.\n *\n * @func\n * @memberOf R\n * @since v0.1.4\n * @category List\n * @sig Number -> Number -> [a] -> [a]\n * @sig Number -> Number -> String -> String\n * @param {Number} fromIndex The start index (inclusive).\n * @param {Number} toIndex The end index (exclusive).\n * @param {*} list\n * @return {*}\n * @example\n *\n *      R.slice(1, 3, ['a', 'b', 'c', 'd']);        //=> ['b', 'c']\n *      R.slice(1, Infinity, ['a', 'b', 'c', 'd']); //=> ['b', 'c', 'd']\n *      R.slice(0, -1, ['a', 'b', 'c', 'd']);       //=> ['a', 'b', 'c']\n *      R.slice(-3, -1, ['a', 'b', 'c', 'd']);      //=> ['b', 'c']\n *      R.slice(0, 3, 'ramda');                     //=> 'ram'\n */\n\nvar slice =\n/*#__PURE__*/\n_curry3(\n/*#__PURE__*/\n_checkForMethod('slice', function slice(fromIndex, toIndex, list) {\n  return Array.prototype.slice.call(list, fromIndex, toIndex);\n}));\n\nexport default slice;","import _checkForMethod from \"./internal/_checkForMethod.js\";\nimport _curry1 from \"./internal/_curry1.js\";\nimport slice from \"./slice.js\";\n/**\n * Returns all but the first element of the given list or string (or object\n * with a `tail` method).\n *\n * Dispatches to the `slice` method of the first argument, if present.\n *\n * @func\n * @memberOf R\n * @since v0.1.0\n * @category List\n * @sig [a] -> [a]\n * @sig String -> String\n * @param {*} list\n * @return {*}\n * @see R.head, R.init, R.last\n * @example\n *\n *      R.tail([1, 2, 3]);  //=> [2, 3]\n *      R.tail([1, 2]);     //=> [2]\n *      R.tail([1]);        //=> []\n *      R.tail([]);         //=> []\n *\n *      R.tail('abc');  //=> 'bc'\n *      R.tail('ab');   //=> 'b'\n *      R.tail('a');    //=> ''\n *      R.tail('');     //=> ''\n */\n\nvar tail =\n/*#__PURE__*/\n_curry1(\n/*#__PURE__*/\n_checkForMethod('tail',\n/*#__PURE__*/\nslice(1, Infinity)));\n\nexport default tail;","import _arity from \"./internal/_arity.js\";\nimport _pipe from \"./internal/_pipe.js\";\nimport reduce from \"./reduce.js\";\nimport tail from \"./tail.js\";\n/**\n * Performs left-to-right function composition. The first argument may have\n * any arity; the remaining arguments must be unary.\n *\n * In some libraries this function is named `sequence`.\n *\n * **Note:** The result of pipe is not automatically curried.\n *\n * @func\n * @memberOf R\n * @since v0.1.0\n * @category Function\n * @sig (((a, b, ..., n) -> o), (o -> p), ..., (x -> y), (y -> z)) -> ((a, b, ..., n) -> z)\n * @param {...Function} functions\n * @return {Function}\n * @see R.compose\n * @example\n *\n *      const f = R.pipe(Math.pow, R.negate, R.inc);\n *\n *      f(3, 4); // -(3^4) + 1\n * @symb R.pipe(f, g, h)(a, b) = h(g(f(a, b)))\n */\n\nexport default function pipe() {\n  if (arguments.length === 0) {\n    throw new Error('pipe requires at least one argument');\n  }\n\n  return _arity(arguments[0].length, reduce(_pipe, arguments[0], tail(arguments)));\n}","import _curry2 from \"./internal/_curry2.js\";\n/**\n * Returns the second argument if it is not `null`, `undefined` or `NaN`;\n * otherwise the first argument is returned.\n *\n * @func\n * @memberOf R\n * @since v0.10.0\n * @category Logic\n * @sig a -> b -> a | b\n * @param {a} default The default value.\n * @param {b} val `val` will be returned instead of `default` unless `val` is `null`, `undefined` or `NaN`.\n * @return {*} The second value if it is not `null`, `undefined` or `NaN`, otherwise the default value\n * @example\n *\n *      const defaultTo42 = R.defaultTo(42);\n *\n *      defaultTo42(null);  //=> 42\n *      defaultTo42(undefined);  //=> 42\n *      defaultTo42(false);  //=> false\n *      defaultTo42('Ramda');  //=> 'Ramda'\n *      // parseInt('string') results in NaN\n *      defaultTo42(parseInt('string')); //=> 42\n */\n\nvar defaultTo =\n/*#__PURE__*/\n_curry2(function defaultTo(d, v) {\n  return v == null || v !== v ? d : v;\n});\n\nexport default defaultTo;","import _curry3 from \"./internal/_curry3.js\";\n/**\n * Removes the sub-list of `list` starting at index `start` and containing\n * `count` elements. _Note that this is not destructive_: it returns a copy of\n * the list with the changes.\n * <small>No lists have been harmed in the application of this function.</small>\n *\n * @func\n * @memberOf R\n * @since v0.2.2\n * @category List\n * @sig Number -> Number -> [a] -> [a]\n * @param {Number} start The position to start removing elements\n * @param {Number} count The number of elements to remove\n * @param {Array} list The list to remove from\n * @return {Array} A new Array with `count` elements from `start` removed.\n * @see R.without\n * @example\n *\n *      R.remove(2, 3, [1,2,3,4,5,6,7,8]); //=> [1,2,6,7,8]\n */\n\nvar remove =\n/*#__PURE__*/\n_curry3(function remove(start, count, list) {\n  var result = Array.prototype.slice.call(list, 0);\n  result.splice(start, count);\n  return result;\n});\n\nexport default remove;","import _curry2 from \"./_curry2.js\";\nimport _xfBase from \"./_xfBase.js\";\n\nvar XDropRepeatsWith =\n/*#__PURE__*/\nfunction () {\n  function XDropRepeatsWith(pred, xf) {\n    this.xf = xf;\n    this.pred = pred;\n    this.lastValue = undefined;\n    this.seenFirstValue = false;\n  }\n\n  XDropRepeatsWith.prototype['@@transducer/init'] = _xfBase.init;\n  XDropRepeatsWith.prototype['@@transducer/result'] = _xfBase.result;\n\n  XDropRepeatsWith.prototype['@@transducer/step'] = function (result, input) {\n    var sameAsLast = false;\n\n    if (!this.seenFirstValue) {\n      this.seenFirstValue = true;\n    } else if (this.pred(this.lastValue, input)) {\n      sameAsLast = true;\n    }\n\n    this.lastValue = input;\n    return sameAsLast ? result : this.xf['@@transducer/step'](result, input);\n  };\n\n  return XDropRepeatsWith;\n}();\n\nvar _xdropRepeatsWith =\n/*#__PURE__*/\n_curry2(function _xdropRepeatsWith(pred, xf) {\n  return new XDropRepeatsWith(pred, xf);\n});\n\nexport default _xdropRepeatsWith;","import nth from \"./nth.js\";\n/**\n * Returns the last element of the given list or string.\n *\n * @func\n * @memberOf R\n * @since v0.1.4\n * @category List\n * @sig [a] -> a | Undefined\n * @sig String -> String\n * @param {*} list\n * @return {*}\n * @see R.init, R.head, R.tail\n * @example\n *\n *      R.last(['fi', 'fo', 'fum']); //=> 'fum'\n *      R.last([]); //=> undefined\n *\n *      R.last('abc'); //=> 'c'\n *      R.last(''); //=> ''\n */\n\nvar last =\n/*#__PURE__*/\nnth(-1);\nexport default last;","import _curry2 from \"./internal/_curry2.js\";\nimport _dispatchable from \"./internal/_dispatchable.js\";\nimport _xdropRepeatsWith from \"./internal/_xdropRepeatsWith.js\";\nimport last from \"./last.js\";\n/**\n * Returns a new list without any consecutively repeating elements. Equality is\n * determined by applying the supplied predicate to each pair of consecutive elements. The\n * first element in a series of equal elements will be preserved.\n *\n * Acts as a transducer if a transformer is given in list position.\n *\n * @func\n * @memberOf R\n * @since v0.14.0\n * @category List\n * @sig ((a, a) -> Boolean) -> [a] -> [a]\n * @param {Function} pred A predicate used to test whether two items are equal.\n * @param {Array} list The array to consider.\n * @return {Array} `list` without repeating elements.\n * @see R.transduce\n * @example\n *\n *      const l = [1, -1, 1, 3, 4, -4, -4, -5, 5, 3, 3];\n *      R.dropRepeatsWith(R.eqBy(Math.abs), l); //=> [1, 3, 4, -5, 3]\n */\n\nvar dropRepeatsWith =\n/*#__PURE__*/\n_curry2(\n/*#__PURE__*/\n_dispatchable([], _xdropRepeatsWith, function dropRepeatsWith(pred, list) {\n  var result = [];\n  var idx = 1;\n  var len = list.length;\n\n  if (len !== 0) {\n    result[0] = list[0];\n\n    while (idx < len) {\n      if (!pred(last(result), list[idx])) {\n        result[result.length] = list[idx];\n      }\n\n      idx += 1;\n    }\n  }\n\n  return result;\n}));\n\nexport default dropRepeatsWith;","import add from \"./add.js\";\nimport reduce from \"./reduce.js\";\n/**\n * Adds together all the elements of a list.\n *\n * @func\n * @memberOf R\n * @since v0.1.0\n * @category Math\n * @sig [Number] -> Number\n * @param {Array} list An array of numbers\n * @return {Number} The sum of all the numbers in the list.\n * @see R.reduce\n * @example\n *\n *      R.sum([2,4,6,8,100,1]); //=> 121\n */\n\nvar sum =\n/*#__PURE__*/\nreduce(add, 0);\nexport default sum;","import _curry1 from \"./internal/_curry1.js\";\nimport sum from \"./sum.js\";\n/**\n * Returns the mean of the given list of numbers.\n *\n * @func\n * @memberOf R\n * @since v0.14.0\n * @category Math\n * @sig [Number] -> Number\n * @param {Array} list\n * @return {Number}\n * @see R.median\n * @example\n *\n *      R.mean([2, 7, 9]); //=> 6\n *      R.mean([]); //=> NaN\n */\n\nvar mean =\n/*#__PURE__*/\n_curry1(function mean(list) {\n  return sum(list) / list.length;\n});\n\nexport default mean;","import { coordAll } from '@turf/meta';\nimport { lineString } from '@turf/helpers';\nimport { getCoord } from '@turf/invariant';\nimport along from '@turf/along';\nimport lineLength from '@turf/length';\nimport bearing from '@turf/bearing';\nimport * as R from 'ramda';\n\nconst TOLERANCE = 0.000001;\n\nconst floatEquals = (f1, f2) => Math.abs(f1 - f2) < TOLERANCE;\n\nconst coordEquals = (c1 = [], c2 = []) => floatEquals(c1[0], c2[0]) && floatEquals(c1[1], c2[1]);\n\nconst asKey = coord => `${coord[0].toFixed(6)},${coord[1].toFixed(6)}`;\n\n// find the point at the given distance ratio on the linestring\nconst project = R.curry((ratio, ls) => {\n  const length = lineLength(ls);\n  const lngLat = getCoord(along(ls, length * ratio));\n  // keep the local bearing of the line to later choose an anchor minimizing the portion of line covered.\n  const localLineBearing = bearing(along(ls, length * (ratio - 0.1), along(length * (ratio + 0.1))));\n\n  return { lngLat, localLineBearing };\n});\n\nfunction distinctSegment(coordinates, coordCounts) {\n  // console.log(coordinates);\n  // const uniqueSegments = R.pipe(\n  //   R.map(coord => coordCounts.get(asKey(coord)) > 1 ? null : coord),\n  //   R.dropRepeatsWith(coordEquals),\n  //   R.splitWhen(R.isNil),\n  //   R.reject(segment => segment[0] === null)\n  // )(coordinates);\n  \n  // if (uniqueSegments.length) {\n  //   return lineString(coordinates);\n  // }\n\n  // const longestSegment = uniqueSegments.reduce((longest, current) => {\n  //   return (current.length > longest.length) ? current : longest;\n  // }, []);\n\n  // return lineString(longestSegment);\n\n  // a distinct segment is a part of a line where coordinates\n  // appear only once accross all the features\n  const start = coordinates.findIndex(coord => coordCounts.get(asKey(coord)) === 1);\n  // in some rare cases, an alternative will share all its parts with others.\n  // when this happens, just return the whole line\n  if (start === -1) {\n    return lineString(coordinates);\n  }\n  const end = start + coordinates\n    .slice(start)\n    .findIndex(coord => coordCounts.get(asKey(coord)) !== 1);\n\n  console.log(start, end);\n\n  return lineString(coordinates.slice(start, end));\n}\n\n// extract the first segment of each linestring\n// whose coordinates don't overlap with another feature\nfunction findDistinctSegments(linestrings) {\n  if (linestrings.length < 2) {\n    return linestrings;\n  }\n\n  // extract raw coordinates\n  const featuresCoords = linestrings.map(coordAll);\n  // count occurences of each coordinate accross all features\n  const coordCounts = new Map();\n  [].concat(...featuresCoords).forEach(coord => {\n    coordCounts.set(asKey(coord), (coordCounts.get(asKey(coord)) || 0) + 1);\n  });\n  return featuresCoords.map(coordinates => distinctSegment(coordinates, coordCounts));\n\n  // // keep occurence counts of each coordinate accross all features\n  // const coordCounts = new Map();\n\n  // return R.pipe(\n  //   R.chain(coordAll),\n  //   R.forEach(coord => {\n  //     coordCounts.set(asKey(coord), (coordCounts.get(asKey(coord)) || 0) + 1);\n  //   }),\n  //   R.map(coordinates => distinctSegment(coordinates, coordCounts))\n  // )(linestrings);\n}\n\nconst toSimpleLinestring = R.pipe(\n  coordAll,\n  R.dropRepeatsWith(coordEquals),\n  lineString,\n);\n\n// Reduce possibilities of collision by chosing anchors so that labels repulse each other\nfunction optimizeAnchors(positions) {\n  return positions.map((position, index) => {\n    const others = R.remove(index, 1, positions);\n    const othersBearing = getBearingFromOtherPoints(position, others);\n    return {\n      lngLat: position.lngLat,\n      anchor: getAnchor(position, othersBearing),\n    };\n  });\n}\n\nfunction getBearingFromOtherPoints(position, others) {\n  return R.pipe(\n    R.map(other => bearing(other.lngLat, position.lngLat)),\n    R.mean,\n    R.defaultTo(0),\n  )(others);\n}\n\nfunction getAnchor(position, otherBearing) {\n  const axis = (Math.abs(position.localLineBearing) < 45 || Math.abs(position.localLineBearing) > 135)\n    ? 'vertical'\n    : 'horizontal';\n\n  if (axis === 'vertical') {\n    return otherBearing > 0 ? 'left' : 'right';\n  }\n  return Math.abs(otherBearing) < 90 ? 'bottom' : 'top';\n}\n\nexport function getLabelPositions(featureCollection) {\n  return R.pipe(\n    R.prop('features'),\n    R.map(toSimpleLinestring),\n    findDistinctSegments,\n    R.map(project(0.5)),\n    optimizeAnchors,\n  )(featureCollection);\n}\n"],"names":["feature","geom","properties","options","feat","type","id","bbox","geometry","point","coordinates","polygon","_i","coordinates_1","length","ring","Error","j","lineString","featureCollection","features","fc","multiLineString","multiPoint","multiPolygon","radiansToLength","radians","units","factor","exports","factors","lengthToRadians","distance","radiansToDegrees","Math","PI","isNumber","num","isNaN","Array","isArray","test","Object","defineProperty","value","centimeters","earthRadius","centimetres","degrees","feet","inches","kilometers","kilometres","meters","metres","miles","millimeters","millimetres","nauticalmiles","yards","acres","map","coords","geometries","precision","multiplier","pow","round","bearing","angle","originalUnit","finalUnit","area","startFactor","areaFactors","finalFactor","input","constructor","forEach","indexOf","coordEach","geojson","callback","excludeWrapCoord","k","l","stopG","geometryMaybeCollection","isGeometryCollection","wrapShrink","coordIndex","isFeatureCollection","isFeature","stop","featureIndex","geomIndex","multiFeatureIndex","geometryIndex","geomType","propEach","i","featureEach","geomEach","g","featureProperties","featureBBox","featureId","undefined","flattenEach","helpers","segmentEach","segmentIndex","previousCoords","previousFeatureIndex","previousMultiIndex","prevGeomIndex","currentCoord","featureIndexCoord","multiPartIndexCoord","currentSegment","lineEach","initialValue","previousValue","currentProperties","currentFeature","coord","push","currentGeometry","started","currentLine","isObject","containsNumber","helpers_1","name","_a","start","end","final","bear","calculateFinalBearing","coordinates1","invariant_1","getCoord","coordinates2","lon1","degreesToRadians","lon2","lat1","lat2","a","sin","cos","b","atan2","origin","longitude1","latitude1","bearingRad","latitude2","asin","longitude2","lng","lat","from","to","dLat","dLon","sqrt","__importDefault","this","mod","__esModule","bearing_1","require$$0","destination_1","require$$1","distance_1","require$$2","line","getGeom","travelled","overshot","direction","default","meta_1","segmentReduce","segment","_isPlaceholder","_curry1","fn","f1","arguments","apply","_curry2","f2","_b","add","Number","_arity","n","a0","a1","a2","a3","a4","a5","a6","a7","a8","a9","_curryN","received","combined","argsIdx","left","combinedIdx","result","curryN","_curry3","f3","c","_c","val","prototype","toString","call","_isTransformer","obj","_dispatchable","methodNames","xf","args","slice","pop","_isArray","idx","transducer","_isString","x","_isArrayLike","nodeType","hasOwnProperty","XWrap","f","acc","bind","thisObj","_iterableReduce","iter","step","next","done","_methodReduce","methodName","symIterator","Symbol","iterator","_reduce","list","_xwrap","len","_arrayReduce","reduce","TypeError","XMap","_xfBase","_xmap","_has","prop","_isArguments","hasEnumBug","propertyIsEnumerable","nonEnumerableProps","hasArgsEnumBug","contains","item","keys","nIdx","ks","checkArgsLength","functor","key","_map","isInteger","nth","offset","charAt","paths","pathsArray","p","_isInteger","path","pathAr","curry","_pipe","_checkForMethod","methodname","tail","fromIndex","toIndex","Infinity","pipe","defaultTo","d","v","remove","count","splice","XDropRepeatsWith","pred","lastValue","seenFirstValue","sameAsLast","_xdropRepeatsWith","last","dropRepeatsWith","sum","mean","floatEquals","abs","asKey","toFixed","project","R","ratio","ls","lineLength","lngLat","along","localLineBearing","findDistinctSegments","linestrings","featuresCoords","coordAll","coordCounts","Map","concat","set","get","findIndex","console","log","distinctSegment","toSimpleLinestring","c1","c2","optimizeAnchors","positions","position","index","othersBearing","others","other","getBearingFromOtherPoints","anchor","getAnchor","otherBearing"],"mappings":"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"}